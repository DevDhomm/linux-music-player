"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tauri-apps+plugin-fs@2.2.0";
exports.ids = ["vendor-chunks/@tauri-apps+plugin-fs@2.2.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@tauri-apps+plugin-fs@2.2.0/node_modules/@tauri-apps/plugin-fs/dist-js/index.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@tauri-apps+plugin-fs@2.2.0/node_modules/@tauri-apps/plugin-fs/dist-js/index.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseDirectory: () => (/* reexport safe */ _tauri_apps_api_path__WEBPACK_IMPORTED_MODULE_0__.BaseDirectory),\n/* harmony export */   FileHandle: () => (/* binding */ FileHandle),\n/* harmony export */   SeekMode: () => (/* binding */ SeekMode),\n/* harmony export */   copyFile: () => (/* binding */ copyFile),\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   lstat: () => (/* binding */ lstat),\n/* harmony export */   mkdir: () => (/* binding */ mkdir),\n/* harmony export */   open: () => (/* binding */ open),\n/* harmony export */   readDir: () => (/* binding */ readDir),\n/* harmony export */   readFile: () => (/* binding */ readFile),\n/* harmony export */   readTextFile: () => (/* binding */ readTextFile),\n/* harmony export */   readTextFileLines: () => (/* binding */ readTextFileLines),\n/* harmony export */   remove: () => (/* binding */ remove),\n/* harmony export */   rename: () => (/* binding */ rename),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   stat: () => (/* binding */ stat),\n/* harmony export */   truncate: () => (/* binding */ truncate),\n/* harmony export */   watch: () => (/* binding */ watch),\n/* harmony export */   watchImmediate: () => (/* binding */ watchImmediate),\n/* harmony export */   writeFile: () => (/* binding */ writeFile),\n/* harmony export */   writeTextFile: () => (/* binding */ writeTextFile)\n/* harmony export */ });\n/* harmony import */ var _tauri_apps_api_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tauri-apps/api/path */ \"(ssr)/./node_modules/.pnpm/@tauri-apps+api@2.2.0/node_modules/@tauri-apps/api/path.js\");\n/* harmony import */ var _tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tauri-apps/api/core */ \"(ssr)/./node_modules/.pnpm/@tauri-apps+api@2.2.0/node_modules/@tauri-apps/api/core.js\");\n\n\n\n// Copyright 2019-2023 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n/**\n * Access the file system.\n *\n * ## Security\n *\n * This module prevents path traversal, not allowing parent directory accessors to be used\n * (i.e. \"/usr/path/to/../file\" or \"../path/to/file\" paths are not allowed).\n * Paths accessed with this API must be either relative to one of the {@link BaseDirectory | base directories}\n * or created with the {@link https://v2.tauri.app/reference/javascript/api/namespacepath | path API}.\n *\n * The API has a scope configuration that forces you to restrict the paths that can be accessed using glob patterns.\n *\n * The scope configuration is an array of glob patterns describing file/directory paths that are allowed.\n * For instance, this scope configuration allows **all** enabled `fs` APIs to (only) access files in the\n * *databases* directory of the {@link https://v2.tauri.app/reference/javascript/api/namespacepath/#appdatadir | `$APPDATA` directory}:\n * ```json\n * {\n *   \"permissions\": [\n *     {\n *       \"identifier\": \"fs:scope\",\n *       \"allow\": [{ \"path\": \"$APPDATA/databases/*\" }]\n *     }\n *   ]\n * }\n * ```\n *\n * Scopes can also be applied to specific `fs` APIs by using the API's identifier instead of `fs:scope`:\n * ```json\n * {\n *   \"permissions\": [\n *     {\n *       \"identifier\": \"fs:allow-exists\",\n *       \"allow\": [{ \"path\": \"$APPDATA/databases/*\" }]\n *     }\n *   ]\n * }\n * ```\n *\n * Notice the use of the `$APPDATA` variable. The value is injected at runtime, resolving to the {@link https://v2.tauri.app/reference/javascript/api/namespacepath/#appdatadir | app data directory}.\n *\n * The available variables are:\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#appconfigdir | $APPCONFIG},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#appdatadir | $APPDATA},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#applocaldatadir | $APPLOCALDATA},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#appcachedir | $APPCACHE},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#applogdir | $APPLOG},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#audiodir | $AUDIO},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#cachedir | $CACHE},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#configdir | $CONFIG},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#datadir | $DATA},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#localdatadir | $LOCALDATA},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#desktopdir | $DESKTOP},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#documentdir | $DOCUMENT},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#downloaddir | $DOWNLOAD},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#executabledir | $EXE},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#fontdir | $FONT},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#homedir | $HOME},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#picturedir | $PICTURE},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#publicdir | $PUBLIC},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#runtimedir | $RUNTIME},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#templatedir | $TEMPLATE},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#videodir | $VIDEO},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#resourcedir | $RESOURCE},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#tempdir | $TEMP}.\n *\n * Trying to execute any API with a URL not configured on the scope results in a promise rejection due to denied access.\n *\n * @module\n */\nvar SeekMode;\n(function (SeekMode) {\n    SeekMode[SeekMode[\"Start\"] = 0] = \"Start\";\n    SeekMode[SeekMode[\"Current\"] = 1] = \"Current\";\n    SeekMode[SeekMode[\"End\"] = 2] = \"End\";\n})(SeekMode || (SeekMode = {}));\nfunction parseFileInfo(r) {\n    return {\n        isFile: r.isFile,\n        isDirectory: r.isDirectory,\n        isSymlink: r.isSymlink,\n        size: r.size,\n        mtime: r.mtime !== null ? new Date(r.mtime) : null,\n        atime: r.atime !== null ? new Date(r.atime) : null,\n        birthtime: r.birthtime !== null ? new Date(r.birthtime) : null,\n        readonly: r.readonly,\n        fileAttributes: r.fileAttributes,\n        dev: r.dev,\n        ino: r.ino,\n        mode: r.mode,\n        nlink: r.nlink,\n        uid: r.uid,\n        gid: r.gid,\n        rdev: r.rdev,\n        blksize: r.blksize,\n        blocks: r.blocks\n    };\n}\n// https://gist.github.com/zapthedingbat/38ebfbedd98396624e5b5f2ff462611d\n/** Converts a big-endian eight byte array to number  */\nfunction fromBytes(buffer) {\n    const bytes = new Uint8ClampedArray(buffer);\n    const size = bytes.byteLength;\n    let x = 0;\n    for (let i = 0; i < size; i++) {\n        // eslint-disable-next-line security/detect-object-injection\n        const byte = bytes[i];\n        x *= 0x100;\n        x += byte;\n    }\n    return x;\n}\n/**\n *  The Tauri abstraction for reading and writing files.\n *\n * @since 2.0.0\n */\nclass FileHandle extends _tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_1__.Resource {\n    /**\n     * Reads up to `p.byteLength` bytes into `p`. It resolves to the number of\n     * bytes read (`0` < `n` <= `p.byteLength`) and rejects if any error\n     * encountered. Even if `read()` resolves to `n` < `p.byteLength`, it may\n     * use all of `p` as scratch space during the call. If some data is\n     * available but not `p.byteLength` bytes, `read()` conventionally resolves\n     * to what is available instead of waiting for more.\n     *\n     * When `read()` encounters end-of-file condition, it resolves to EOF\n     * (`null`).\n     *\n     * When `read()` encounters an error, it rejects with an error.\n     *\n     * Callers should always process the `n` > `0` bytes returned before\n     * considering the EOF (`null`). Doing so correctly handles I/O errors that\n     * happen after reading some bytes and also both of the allowed EOF\n     * behaviors.\n     *\n     * @example\n     * ```typescript\n     * import { open, BaseDirectory } from \"@tauri-apps/plugin-fs\"\n     * // if \"$APPCONFIG/foo/bar.txt\" contains the text \"hello world\":\n     * const file = await open(\"foo/bar.txt\", { baseDir: BaseDirectory.AppConfig });\n     * const buf = new Uint8Array(100);\n     * const numberOfBytesRead = await file.read(buf); // 11 bytes\n     * const text = new TextDecoder().decode(buf);  // \"hello world\"\n     * await file.close();\n     * ```\n     *\n     * @since 2.0.0\n     */\n    async read(buffer) {\n        if (buffer.byteLength === 0) {\n            return 0;\n        }\n        const data = await (0,_tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_1__.invoke)('plugin:fs|read', {\n            rid: this.rid,\n            len: buffer.byteLength\n        });\n        // Rust side will never return an empty array for this command and\n        // ensure there is at least 8 elements there.\n        //\n        // This is an optimization to include the number of read bytes (as bigendian bytes)\n        // at the end of returned array to avoid serialization overhead of separate values.\n        const nread = fromBytes(data.slice(-8));\n        const bytes = data instanceof ArrayBuffer ? new Uint8Array(data) : data;\n        buffer.set(bytes.slice(0, bytes.length - 8));\n        return nread === 0 ? null : nread;\n    }\n    /**\n     * Seek sets the offset for the next `read()` or `write()` to offset,\n     * interpreted according to `whence`: `Start` means relative to the\n     * start of the file, `Current` means relative to the current offset,\n     * and `End` means relative to the end. Seek resolves to the new offset\n     * relative to the start of the file.\n     *\n     * Seeking to an offset before the start of the file is an error. Seeking to\n     * any positive offset is legal, but the behavior of subsequent I/O\n     * operations on the underlying object is implementation-dependent.\n     * It returns the number of cursor position.\n     *\n     * @example\n     * ```typescript\n     * import { open, SeekMode, BaseDirectory } from '@tauri-apps/plugin-fs';\n     *\n     * // Given hello.txt pointing to file with \"Hello world\", which is 11 bytes long:\n     * const file = await open('hello.txt', { read: true, write: true, truncate: true, create: true, baseDir: BaseDirectory.AppLocalData });\n     * await file.write(new TextEncoder().encode(\"Hello world\"));\n     *\n     * // Seek 6 bytes from the start of the file\n     * console.log(await file.seek(6, SeekMode.Start)); // \"6\"\n     * // Seek 2 more bytes from the current position\n     * console.log(await file.seek(2, SeekMode.Current)); // \"8\"\n     * // Seek backwards 2 bytes from the end of the file\n     * console.log(await file.seek(-2, SeekMode.End)); // \"9\" (e.g. 11-2)\n     *\n     * await file.close();\n     * ```\n     *\n     * @since 2.0.0\n     */\n    async seek(offset, whence) {\n        return await (0,_tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_1__.invoke)('plugin:fs|seek', {\n            rid: this.rid,\n            offset,\n            whence\n        });\n    }\n    /**\n     * Returns a {@linkcode FileInfo } for this file.\n     *\n     * @example\n     * ```typescript\n     * import { open, BaseDirectory } from '@tauri-apps/plugin-fs';\n     * const file = await open(\"file.txt\", { read: true, baseDir: BaseDirectory.AppLocalData });\n     * const fileInfo = await file.stat();\n     * console.log(fileInfo.isFile); // true\n     * await file.close();\n     * ```\n     *\n     * @since 2.0.0\n     */\n    async stat() {\n        const res = await (0,_tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_1__.invoke)('plugin:fs|fstat', {\n            rid: this.rid\n        });\n        return parseFileInfo(res);\n    }\n    /**\n     * Truncates or extends this file, to reach the specified `len`.\n     * If `len` is not specified then the entire file contents are truncated.\n     *\n     * @example\n     * ```typescript\n     * import { open, BaseDirectory } from '@tauri-apps/plugin-fs';\n     *\n     * // truncate the entire file\n     * const file = await open(\"my_file.txt\", { read: true, write: true, create: true, baseDir: BaseDirectory.AppLocalData });\n     * await file.truncate();\n     *\n     * // truncate part of the file\n     * const file = await open(\"my_file.txt\", { read: true, write: true, create: true, baseDir: BaseDirectory.AppLocalData });\n     * await file.write(new TextEncoder().encode(\"Hello World\"));\n     * await file.truncate(7);\n     * const data = new Uint8Array(32);\n     * await file.read(data);\n     * console.log(new TextDecoder().decode(data)); // Hello W\n     * await file.close();\n     * ```\n     *\n     * @since 2.0.0\n     */\n    async truncate(len) {\n        await (0,_tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_1__.invoke)('plugin:fs|ftruncate', {\n            rid: this.rid,\n            len\n        });\n    }\n    /**\n     * Writes `data.byteLength` bytes from `data` to the underlying data stream. It\n     * resolves to the number of bytes written from `data` (`0` <= `n` <=\n     * `data.byteLength`) or reject with the error encountered that caused the\n     * write to stop early. `write()` must reject with a non-null error if\n     * would resolve to `n` < `data.byteLength`. `write()` must not modify the\n     * slice data, even temporarily.\n     *\n     * @example\n     * ```typescript\n     * import { open, write, BaseDirectory } from '@tauri-apps/plugin-fs';\n     * const encoder = new TextEncoder();\n     * const data = encoder.encode(\"Hello world\");\n     * const file = await open(\"bar.txt\", { write: true, baseDir: BaseDirectory.AppLocalData });\n     * const bytesWritten = await file.write(data); // 11\n     * await file.close();\n     * ```\n     *\n     * @since 2.0.0\n     */\n    async write(data) {\n        return await (0,_tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_1__.invoke)('plugin:fs|write', {\n            rid: this.rid,\n            data\n        });\n    }\n}\n/**\n * Creates a file if none exists or truncates an existing file and resolves to\n *  an instance of {@linkcode FileHandle }.\n *\n * @example\n * ```typescript\n * import { create, BaseDirectory } from \"@tauri-apps/plugin-fs\"\n * const file = await create(\"foo/bar.txt\", { baseDir: BaseDirectory.AppConfig });\n * await file.write(new TextEncoder().encode(\"Hello world\"));\n * await file.close();\n * ```\n *\n * @since 2.0.0\n */\nasync function create(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    const rid = await (0,_tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_1__.invoke)('plugin:fs|create', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n    return new FileHandle(rid);\n}\n/**\n * Open a file and resolve to an instance of {@linkcode FileHandle}. The\n * file does not need to previously exist if using the `create` or `createNew`\n * open options. It is the callers responsibility to close the file when finished\n * with it.\n *\n * @example\n * ```typescript\n * import { open, BaseDirectory } from \"@tauri-apps/plugin-fs\"\n * const file = await open(\"foo/bar.txt\", { read: true, write: true, baseDir: BaseDirectory.AppLocalData });\n * // Do work with file\n * await file.close();\n * ```\n *\n * @since 2.0.0\n */\nasync function open(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    const rid = await (0,_tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_1__.invoke)('plugin:fs|open', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n    return new FileHandle(rid);\n}\n/**\n * Copies the contents and permissions of one file to another specified path, by default creating a new file if needed, else overwriting.\n * @example\n * ```typescript\n * import { copyFile, BaseDirectory } from '@tauri-apps/plugin-fs';\n * await copyFile('app.conf', 'app.conf.bk', { fromPathBaseDir: BaseDirectory.AppConfig, toPathBaseDir: BaseDirectory.AppConfig });\n * ```\n *\n * @since 2.0.0\n */\nasync function copyFile(fromPath, toPath, options) {\n    if ((fromPath instanceof URL && fromPath.protocol !== 'file:') ||\n        (toPath instanceof URL && toPath.protocol !== 'file:')) {\n        throw new TypeError('Must be a file URL.');\n    }\n    await (0,_tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_1__.invoke)('plugin:fs|copy_file', {\n        fromPath: fromPath instanceof URL ? fromPath.toString() : fromPath,\n        toPath: toPath instanceof URL ? toPath.toString() : toPath,\n        options\n    });\n}\n/**\n * Creates a new directory with the specified path.\n * @example\n * ```typescript\n * import { mkdir, BaseDirectory } from '@tauri-apps/plugin-fs';\n * await mkdir('users', { baseDir: BaseDirectory.AppLocalData });\n * ```\n *\n * @since 2.0.0\n */\nasync function mkdir(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    await (0,_tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_1__.invoke)('plugin:fs|mkdir', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n}\n/**\n * Reads the directory given by path and returns an array of `DirEntry`.\n * @example\n * ```typescript\n * import { readDir, BaseDirectory } from '@tauri-apps/plugin-fs';\n * import { join } from '@tauri-apps/api/path';\n * const dir = \"users\"\n * const entries = await readDir('users', { baseDir: BaseDirectory.AppLocalData });\n * processEntriesRecursively(dir, entries);\n * async function processEntriesRecursively(parent, entries) {\n *   for (const entry of entries) {\n *     console.log(`Entry: ${entry.name}`);\n *     if (entry.isDirectory) {\n *        const dir = await join(parent, entry.name);\n *       processEntriesRecursively(dir, await readDir(dir, { baseDir: BaseDirectory.AppLocalData }))\n *     }\n *   }\n * }\n * ```\n *\n * @since 2.0.0\n */\nasync function readDir(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    return await (0,_tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_1__.invoke)('plugin:fs|read_dir', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n}\n/**\n * Reads and resolves to the entire contents of a file as an array of bytes.\n * TextDecoder can be used to transform the bytes to string if required.\n * @example\n * ```typescript\n * import { readFile, BaseDirectory } from '@tauri-apps/plugin-fs';\n * const contents = await readFile('avatar.png', { baseDir: BaseDirectory.Resource });\n * ```\n *\n * @since 2.0.0\n */\nasync function readFile(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    const arr = await (0,_tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_1__.invoke)('plugin:fs|read_file', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n    return arr instanceof ArrayBuffer ? new Uint8Array(arr) : Uint8Array.from(arr);\n}\n/**\n * Reads and returns the entire contents of a file as UTF-8 string.\n * @example\n * ```typescript\n * import { readTextFile, BaseDirectory } from '@tauri-apps/plugin-fs';\n * const contents = await readTextFile('app.conf', { baseDir: BaseDirectory.AppConfig });\n * ```\n *\n * @since 2.0.0\n */\nasync function readTextFile(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    const arr = await (0,_tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_1__.invoke)('plugin:fs|read_text_file', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n    const bytes = arr instanceof ArrayBuffer ? arr : Uint8Array.from(arr);\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Returns an async {@linkcode AsyncIterableIterator} over the lines of a file as UTF-8 string.\n * @example\n * ```typescript\n * import { readTextFileLines, BaseDirectory } from '@tauri-apps/plugin-fs';\n * const lines = await readTextFileLines('app.conf', { baseDir: BaseDirectory.AppConfig });\n * for await (const line of lines) {\n *   console.log(line);\n * }\n * ```\n * You could also call {@linkcode AsyncIterableIterator.next} to advance the\n * iterator so you can lazily read the next line whenever you want.\n *\n * @since 2.0.0\n */\nasync function readTextFileLines(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    const pathStr = path instanceof URL ? path.toString() : path;\n    return await Promise.resolve({\n        path: pathStr,\n        rid: null,\n        async next() {\n            if (this.rid === null) {\n                this.rid = await (0,_tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_1__.invoke)('plugin:fs|read_text_file_lines', {\n                    path: pathStr,\n                    options\n                });\n            }\n            const arr = await (0,_tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_1__.invoke)('plugin:fs|read_text_file_lines_next', { rid: this.rid });\n            const bytes = arr instanceof ArrayBuffer ? new Uint8Array(arr) : Uint8Array.from(arr);\n            // Rust side will never return an empty array for this command and\n            // ensure there is at least one elements there.\n            //\n            // This is an optimization to include whether we finished iteration or not (1 or 0)\n            // at the end of returned array to avoid serialization overhead of separate values.\n            const done = bytes[bytes.byteLength - 1] === 1;\n            if (done) {\n                // a full iteration is over, reset rid for next iteration\n                this.rid = null;\n                return { value: null, done };\n            }\n            const line = new TextDecoder().decode(bytes.slice(0, bytes.byteLength));\n            return {\n                value: line,\n                done\n            };\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        }\n    });\n}\n/**\n * Removes the named file or directory.\n * If the directory is not empty and the `recursive` option isn't set to true, the promise will be rejected.\n * @example\n * ```typescript\n * import { remove, BaseDirectory } from '@tauri-apps/plugin-fs';\n * await remove('users/file.txt', { baseDir: BaseDirectory.AppLocalData });\n * await remove('users', { baseDir: BaseDirectory.AppLocalData });\n * ```\n *\n * @since 2.0.0\n */\nasync function remove(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    await (0,_tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_1__.invoke)('plugin:fs|remove', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n}\n/**\n * Renames (moves) oldpath to newpath. Paths may be files or directories.\n * If newpath already exists and is not a directory, rename() replaces it.\n * OS-specific restrictions may apply when oldpath and newpath are in different directories.\n *\n * On Unix, this operation does not follow symlinks at either path.\n *\n * @example\n * ```typescript\n * import { rename, BaseDirectory } from '@tauri-apps/plugin-fs';\n * await rename('avatar.png', 'deleted.png', { oldPathBaseDir: BaseDirectory.App, newPathBaseDir: BaseDirectory.AppLocalData });\n * ```\n *\n * @since 2.0.0\n */\nasync function rename(oldPath, newPath, options) {\n    if ((oldPath instanceof URL && oldPath.protocol !== 'file:') ||\n        (newPath instanceof URL && newPath.protocol !== 'file:')) {\n        throw new TypeError('Must be a file URL.');\n    }\n    await (0,_tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_1__.invoke)('plugin:fs|rename', {\n        oldPath: oldPath instanceof URL ? oldPath.toString() : oldPath,\n        newPath: newPath instanceof URL ? newPath.toString() : newPath,\n        options\n    });\n}\n/**\n * Resolves to a {@linkcode FileInfo} for the specified `path`. Will always\n * follow symlinks but will reject if the symlink points to a path outside of the scope.\n *\n * @example\n * ```typescript\n * import { stat, BaseDirectory } from '@tauri-apps/plugin-fs';\n * const fileInfo = await stat(\"hello.txt\", { baseDir: BaseDirectory.AppLocalData });\n * console.log(fileInfo.isFile); // true\n * ```\n *\n * @since 2.0.0\n */\nasync function stat(path, options) {\n    const res = await (0,_tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_1__.invoke)('plugin:fs|stat', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n    return parseFileInfo(res);\n}\n/**\n * Resolves to a {@linkcode FileInfo} for the specified `path`. If `path` is a\n * symlink, information for the symlink will be returned instead of what it\n * points to.\n *\n * @example\n * ```typescript\n * import { lstat, BaseDirectory } from '@tauri-apps/plugin-fs';\n * const fileInfo = await lstat(\"hello.txt\", { baseDir: BaseDirectory.AppLocalData });\n * console.log(fileInfo.isFile); // true\n * ```\n *\n * @since 2.0.0\n */\nasync function lstat(path, options) {\n    const res = await (0,_tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_1__.invoke)('plugin:fs|lstat', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n    return parseFileInfo(res);\n}\n/**\n * Truncates or extends the specified file, to reach the specified `len`.\n * If `len` is `0` or not specified, then the entire file contents are truncated.\n *\n * @example\n * ```typescript\n * import { truncate, readTextFile, writeTextFile, BaseDirectory } from '@tauri-apps/plugin-fs';\n * // truncate the entire file\n * await truncate(\"my_file.txt\", 0, { baseDir: BaseDirectory.AppLocalData });\n *\n * // truncate part of the file\n * const filePath = \"file.txt\";\n * await writeTextFile(filePath, \"Hello World\", { baseDir: BaseDirectory.AppLocalData });\n * await truncate(filePath, 7, { baseDir: BaseDirectory.AppLocalData });\n * const data = await readTextFile(filePath, { baseDir: BaseDirectory.AppLocalData });\n * console.log(data);  // \"Hello W\"\n * ```\n *\n * @since 2.0.0\n */\nasync function truncate(path, len, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    await (0,_tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_1__.invoke)('plugin:fs|truncate', {\n        path: path instanceof URL ? path.toString() : path,\n        len,\n        options\n    });\n}\n/**\n * Write `data` to the given `path`, by default creating a new file if needed, else overwriting.\n * @example\n * ```typescript\n * import { writeFile, BaseDirectory } from '@tauri-apps/plugin-fs';\n *\n * let encoder = new TextEncoder();\n * let data = encoder.encode(\"Hello World\");\n * await writeFile('file.txt', data, { baseDir: BaseDirectory.AppLocalData });\n * ```\n *\n * @since 2.0.0\n */\nasync function writeFile(path, data, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    if (data instanceof ReadableStream) {\n        const file = await open(path, options);\n        for await (const chunk of data) {\n            await file.write(chunk);\n        }\n        await file.close();\n    }\n    else {\n        await (0,_tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_1__.invoke)('plugin:fs|write_file', data, {\n            headers: {\n                path: encodeURIComponent(path instanceof URL ? path.toString() : path),\n                options: JSON.stringify(options)\n            }\n        });\n    }\n}\n/**\n  * Writes UTF-8 string `data` to the given `path`, by default creating a new file if needed, else overwriting.\n    @example\n  * ```typescript\n  * import { writeTextFile, BaseDirectory } from '@tauri-apps/plugin-fs';\n  *\n  * await writeTextFile('file.txt', \"Hello world\", { baseDir: BaseDirectory.AppLocalData });\n  * ```\n  *\n  * @since 2.0.0\n  */\nasync function writeTextFile(path, data, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    const encoder = new TextEncoder();\n    await (0,_tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_1__.invoke)('plugin:fs|write_text_file', encoder.encode(data), {\n        headers: {\n            path: encodeURIComponent(path instanceof URL ? path.toString() : path),\n            options: JSON.stringify(options)\n        }\n    });\n}\n/**\n * Check if a path exists.\n * @example\n * ```typescript\n * import { exists, BaseDirectory } from '@tauri-apps/plugin-fs';\n * // Check if the `$APPDATA/avatar.png` file exists\n * await exists('avatar.png', { baseDir: BaseDirectory.AppData });\n * ```\n *\n * @since 2.0.0\n */\nasync function exists(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    return await (0,_tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_1__.invoke)('plugin:fs|exists', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n}\nasync function unwatch(rid) {\n    await (0,_tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_1__.invoke)('plugin:fs|unwatch', { rid });\n}\n/**\n * Watch changes (after a delay) on files or directories.\n *\n * @since 2.0.0\n */\nasync function watch(paths, cb, options) {\n    const opts = {\n        recursive: false,\n        delayMs: 2000,\n        ...options\n    };\n    const watchPaths = Array.isArray(paths) ? paths : [paths];\n    for (const path of watchPaths) {\n        if (path instanceof URL && path.protocol !== 'file:') {\n            throw new TypeError('Must be a file URL.');\n        }\n    }\n    const onEvent = new _tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_1__.Channel();\n    onEvent.onmessage = cb;\n    const rid = await (0,_tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_1__.invoke)('plugin:fs|watch', {\n        paths: watchPaths.map((p) => (p instanceof URL ? p.toString() : p)),\n        options: opts,\n        onEvent\n    });\n    return () => {\n        void unwatch(rid);\n    };\n}\n/**\n * Watch changes on files or directories.\n *\n * @since 2.0.0\n */\nasync function watchImmediate(paths, cb, options) {\n    const opts = {\n        recursive: false,\n        ...options,\n        delayMs: null\n    };\n    const watchPaths = Array.isArray(paths) ? paths : [paths];\n    for (const path of watchPaths) {\n        if (path instanceof URL && path.protocol !== 'file:') {\n            throw new TypeError('Must be a file URL.');\n        }\n    }\n    const onEvent = new _tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_1__.Channel();\n    onEvent.onmessage = cb;\n    const rid = await (0,_tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_1__.invoke)('plugin:fs|watch', {\n        paths: watchPaths.map((p) => (p instanceof URL ? p.toString() : p)),\n        options: opts,\n        onEvent\n    });\n    return () => {\n        void unwatch(rid);\n    };\n}\n/**\n * Get the size of a file or directory. For files, the `stat` functions can be used as well.\n *\n * If `path` is a directory, this function will recursively iterate over every file and every directory inside of `path` and therefore will be very time consuming if used on larger directories.\n *\n * @example\n * ```typescript\n * import { size, BaseDirectory } from '@tauri-apps/plugin-fs';\n * // Get the size of the `$APPDATA/tauri` directory.\n * const dirSize = await size('tauri', { baseDir: BaseDirectory.AppData });\n * console.log(dirSize); // 1024\n * ```\n *\n * @since 2.1.0\n */\nasync function size(path) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    return await (0,_tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_1__.invoke)('plugin:fs|size', {\n        path: path instanceof URL ? path.toString() : path\n    });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRhdXJpLWFwcHMrcGx1Z2luLWZzQDIuMi4wL25vZGVfbW9kdWxlcy9AdGF1cmktYXBwcy9wbHVnaW4tZnMvZGlzdC1qcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUQ7QUFDWTs7QUFFakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkUsd0JBQXdCLDZFQUE2RTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHFHQUFxRztBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdDQUFnQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdDQUFnQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHLG1HQUFtRztBQUNyTTtBQUNBO0FBQ0EsSUFBSSxpR0FBaUc7QUFDckcsSUFBSSw2RkFBNkY7QUFDakcsSUFBSSx1R0FBdUc7QUFDM0csSUFBSSwrRkFBK0Y7QUFDbkcsSUFBSSwyRkFBMkY7QUFDL0YsSUFBSSx5RkFBeUY7QUFDN0YsSUFBSSx5RkFBeUY7QUFDN0YsSUFBSSwyRkFBMkY7QUFDL0YsSUFBSSx1RkFBdUY7QUFDM0YsSUFBSSxpR0FBaUc7QUFDckcsSUFBSSw2RkFBNkY7QUFDakcsSUFBSSwrRkFBK0Y7QUFDbkcsSUFBSSwrRkFBK0Y7QUFDbkcsSUFBSSw0RkFBNEY7QUFDaEcsSUFBSSx1RkFBdUY7QUFDM0YsSUFBSSx1RkFBdUY7QUFDM0YsSUFBSSw2RkFBNkY7QUFDakcsSUFBSSwyRkFBMkY7QUFDL0YsSUFBSSw2RkFBNkY7QUFDakcsSUFBSSwrRkFBK0Y7QUFDbkcsSUFBSSx5RkFBeUY7QUFDN0YsSUFBSSwrRkFBK0Y7QUFDbkcsSUFBSSx1RkFBdUY7QUFD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Q0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFVBQVUsNERBQU0sd0JBQXdCLEtBQUs7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlEQUFPO0FBQy9CO0FBQ0Esc0JBQXNCLDREQUFNO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseURBQU87QUFDL0I7QUFDQSxzQkFBc0IsNERBQU07QUFDNUI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBLHlDQUF5QyxnQ0FBZ0M7QUFDekUseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNERBQU07QUFDdkI7QUFDQSxLQUFLO0FBQ0w7O0FBRXlOIiwic291cmNlcyI6WyIvaG9tZS9saWxhcy9CdXJlYXUvRGV2L0xNUC9ub2RlX21vZHVsZXMvLnBucG0vQHRhdXJpLWFwcHMrcGx1Z2luLWZzQDIuMi4wL25vZGVfbW9kdWxlcy9AdGF1cmktYXBwcy9wbHVnaW4tZnMvZGlzdC1qcy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBCYXNlRGlyZWN0b3J5IH0gZnJvbSAnQHRhdXJpLWFwcHMvYXBpL3BhdGgnO1xuaW1wb3J0IHsgUmVzb3VyY2UsIGludm9rZSwgQ2hhbm5lbCB9IGZyb20gJ0B0YXVyaS1hcHBzL2FwaS9jb3JlJztcblxuLy8gQ29weXJpZ2h0IDIwMTktMjAyMyBUYXVyaSBQcm9ncmFtbWUgd2l0aGluIFRoZSBDb21tb25zIENvbnNlcnZhbmN5XG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVFxuLyoqXG4gKiBBY2Nlc3MgdGhlIGZpbGUgc3lzdGVtLlxuICpcbiAqICMjIFNlY3VyaXR5XG4gKlxuICogVGhpcyBtb2R1bGUgcHJldmVudHMgcGF0aCB0cmF2ZXJzYWwsIG5vdCBhbGxvd2luZyBwYXJlbnQgZGlyZWN0b3J5IGFjY2Vzc29ycyB0byBiZSB1c2VkXG4gKiAoaS5lLiBcIi91c3IvcGF0aC90by8uLi9maWxlXCIgb3IgXCIuLi9wYXRoL3RvL2ZpbGVcIiBwYXRocyBhcmUgbm90IGFsbG93ZWQpLlxuICogUGF0aHMgYWNjZXNzZWQgd2l0aCB0aGlzIEFQSSBtdXN0IGJlIGVpdGhlciByZWxhdGl2ZSB0byBvbmUgb2YgdGhlIHtAbGluayBCYXNlRGlyZWN0b3J5IHwgYmFzZSBkaXJlY3Rvcmllc31cbiAqIG9yIGNyZWF0ZWQgd2l0aCB0aGUge0BsaW5rIGh0dHBzOi8vdjIudGF1cmkuYXBwL3JlZmVyZW5jZS9qYXZhc2NyaXB0L2FwaS9uYW1lc3BhY2VwYXRoIHwgcGF0aCBBUEl9LlxuICpcbiAqIFRoZSBBUEkgaGFzIGEgc2NvcGUgY29uZmlndXJhdGlvbiB0aGF0IGZvcmNlcyB5b3UgdG8gcmVzdHJpY3QgdGhlIHBhdGhzIHRoYXQgY2FuIGJlIGFjY2Vzc2VkIHVzaW5nIGdsb2IgcGF0dGVybnMuXG4gKlxuICogVGhlIHNjb3BlIGNvbmZpZ3VyYXRpb24gaXMgYW4gYXJyYXkgb2YgZ2xvYiBwYXR0ZXJucyBkZXNjcmliaW5nIGZpbGUvZGlyZWN0b3J5IHBhdGhzIHRoYXQgYXJlIGFsbG93ZWQuXG4gKiBGb3IgaW5zdGFuY2UsIHRoaXMgc2NvcGUgY29uZmlndXJhdGlvbiBhbGxvd3MgKiphbGwqKiBlbmFibGVkIGBmc2AgQVBJcyB0byAob25seSkgYWNjZXNzIGZpbGVzIGluIHRoZVxuICogKmRhdGFiYXNlcyogZGlyZWN0b3J5IG9mIHRoZSB7QGxpbmsgaHR0cHM6Ly92Mi50YXVyaS5hcHAvcmVmZXJlbmNlL2phdmFzY3JpcHQvYXBpL25hbWVzcGFjZXBhdGgvI2FwcGRhdGFkaXIgfCBgJEFQUERBVEFgIGRpcmVjdG9yeX06XG4gKiBgYGBqc29uXG4gKiB7XG4gKiAgIFwicGVybWlzc2lvbnNcIjogW1xuICogICAgIHtcbiAqICAgICAgIFwiaWRlbnRpZmllclwiOiBcImZzOnNjb3BlXCIsXG4gKiAgICAgICBcImFsbG93XCI6IFt7IFwicGF0aFwiOiBcIiRBUFBEQVRBL2RhdGFiYXNlcy8qXCIgfV1cbiAqICAgICB9XG4gKiAgIF1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIFNjb3BlcyBjYW4gYWxzbyBiZSBhcHBsaWVkIHRvIHNwZWNpZmljIGBmc2AgQVBJcyBieSB1c2luZyB0aGUgQVBJJ3MgaWRlbnRpZmllciBpbnN0ZWFkIG9mIGBmczpzY29wZWA6XG4gKiBgYGBqc29uXG4gKiB7XG4gKiAgIFwicGVybWlzc2lvbnNcIjogW1xuICogICAgIHtcbiAqICAgICAgIFwiaWRlbnRpZmllclwiOiBcImZzOmFsbG93LWV4aXN0c1wiLFxuICogICAgICAgXCJhbGxvd1wiOiBbeyBcInBhdGhcIjogXCIkQVBQREFUQS9kYXRhYmFzZXMvKlwiIH1dXG4gKiAgICAgfVxuICogICBdXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBOb3RpY2UgdGhlIHVzZSBvZiB0aGUgYCRBUFBEQVRBYCB2YXJpYWJsZS4gVGhlIHZhbHVlIGlzIGluamVjdGVkIGF0IHJ1bnRpbWUsIHJlc29sdmluZyB0byB0aGUge0BsaW5rIGh0dHBzOi8vdjIudGF1cmkuYXBwL3JlZmVyZW5jZS9qYXZhc2NyaXB0L2FwaS9uYW1lc3BhY2VwYXRoLyNhcHBkYXRhZGlyIHwgYXBwIGRhdGEgZGlyZWN0b3J5fS5cbiAqXG4gKiBUaGUgYXZhaWxhYmxlIHZhcmlhYmxlcyBhcmU6XG4gKiB7QGxpbmtjb2RlIGh0dHBzOi8vdjIudGF1cmkuYXBwL3JlZmVyZW5jZS9qYXZhc2NyaXB0L2FwaS9uYW1lc3BhY2VwYXRoLyNhcHBjb25maWdkaXIgfCAkQVBQQ09ORklHfSxcbiAqIHtAbGlua2NvZGUgaHR0cHM6Ly92Mi50YXVyaS5hcHAvcmVmZXJlbmNlL2phdmFzY3JpcHQvYXBpL25hbWVzcGFjZXBhdGgvI2FwcGRhdGFkaXIgfCAkQVBQREFUQX0sXG4gKiB7QGxpbmtjb2RlIGh0dHBzOi8vdjIudGF1cmkuYXBwL3JlZmVyZW5jZS9qYXZhc2NyaXB0L2FwaS9uYW1lc3BhY2VwYXRoLyNhcHBsb2NhbGRhdGFkaXIgfCAkQVBQTE9DQUxEQVRBfSxcbiAqIHtAbGlua2NvZGUgaHR0cHM6Ly92Mi50YXVyaS5hcHAvcmVmZXJlbmNlL2phdmFzY3JpcHQvYXBpL25hbWVzcGFjZXBhdGgvI2FwcGNhY2hlZGlyIHwgJEFQUENBQ0hFfSxcbiAqIHtAbGlua2NvZGUgaHR0cHM6Ly92Mi50YXVyaS5hcHAvcmVmZXJlbmNlL2phdmFzY3JpcHQvYXBpL25hbWVzcGFjZXBhdGgvI2FwcGxvZ2RpciB8ICRBUFBMT0d9LFxuICoge0BsaW5rY29kZSBodHRwczovL3YyLnRhdXJpLmFwcC9yZWZlcmVuY2UvamF2YXNjcmlwdC9hcGkvbmFtZXNwYWNlcGF0aC8jYXVkaW9kaXIgfCAkQVVESU99LFxuICoge0BsaW5rY29kZSBodHRwczovL3YyLnRhdXJpLmFwcC9yZWZlcmVuY2UvamF2YXNjcmlwdC9hcGkvbmFtZXNwYWNlcGF0aC8jY2FjaGVkaXIgfCAkQ0FDSEV9LFxuICoge0BsaW5rY29kZSBodHRwczovL3YyLnRhdXJpLmFwcC9yZWZlcmVuY2UvamF2YXNjcmlwdC9hcGkvbmFtZXNwYWNlcGF0aC8jY29uZmlnZGlyIHwgJENPTkZJR30sXG4gKiB7QGxpbmtjb2RlIGh0dHBzOi8vdjIudGF1cmkuYXBwL3JlZmVyZW5jZS9qYXZhc2NyaXB0L2FwaS9uYW1lc3BhY2VwYXRoLyNkYXRhZGlyIHwgJERBVEF9LFxuICoge0BsaW5rY29kZSBodHRwczovL3YyLnRhdXJpLmFwcC9yZWZlcmVuY2UvamF2YXNjcmlwdC9hcGkvbmFtZXNwYWNlcGF0aC8jbG9jYWxkYXRhZGlyIHwgJExPQ0FMREFUQX0sXG4gKiB7QGxpbmtjb2RlIGh0dHBzOi8vdjIudGF1cmkuYXBwL3JlZmVyZW5jZS9qYXZhc2NyaXB0L2FwaS9uYW1lc3BhY2VwYXRoLyNkZXNrdG9wZGlyIHwgJERFU0tUT1B9LFxuICoge0BsaW5rY29kZSBodHRwczovL3YyLnRhdXJpLmFwcC9yZWZlcmVuY2UvamF2YXNjcmlwdC9hcGkvbmFtZXNwYWNlcGF0aC8jZG9jdW1lbnRkaXIgfCAkRE9DVU1FTlR9LFxuICoge0BsaW5rY29kZSBodHRwczovL3YyLnRhdXJpLmFwcC9yZWZlcmVuY2UvamF2YXNjcmlwdC9hcGkvbmFtZXNwYWNlcGF0aC8jZG93bmxvYWRkaXIgfCAkRE9XTkxPQUR9LFxuICoge0BsaW5rY29kZSBodHRwczovL3YyLnRhdXJpLmFwcC9yZWZlcmVuY2UvamF2YXNjcmlwdC9hcGkvbmFtZXNwYWNlcGF0aC8jZXhlY3V0YWJsZWRpciB8ICRFWEV9LFxuICoge0BsaW5rY29kZSBodHRwczovL3YyLnRhdXJpLmFwcC9yZWZlcmVuY2UvamF2YXNjcmlwdC9hcGkvbmFtZXNwYWNlcGF0aC8jZm9udGRpciB8ICRGT05UfSxcbiAqIHtAbGlua2NvZGUgaHR0cHM6Ly92Mi50YXVyaS5hcHAvcmVmZXJlbmNlL2phdmFzY3JpcHQvYXBpL25hbWVzcGFjZXBhdGgvI2hvbWVkaXIgfCAkSE9NRX0sXG4gKiB7QGxpbmtjb2RlIGh0dHBzOi8vdjIudGF1cmkuYXBwL3JlZmVyZW5jZS9qYXZhc2NyaXB0L2FwaS9uYW1lc3BhY2VwYXRoLyNwaWN0dXJlZGlyIHwgJFBJQ1RVUkV9LFxuICoge0BsaW5rY29kZSBodHRwczovL3YyLnRhdXJpLmFwcC9yZWZlcmVuY2UvamF2YXNjcmlwdC9hcGkvbmFtZXNwYWNlcGF0aC8jcHVibGljZGlyIHwgJFBVQkxJQ30sXG4gKiB7QGxpbmtjb2RlIGh0dHBzOi8vdjIudGF1cmkuYXBwL3JlZmVyZW5jZS9qYXZhc2NyaXB0L2FwaS9uYW1lc3BhY2VwYXRoLyNydW50aW1lZGlyIHwgJFJVTlRJTUV9LFxuICoge0BsaW5rY29kZSBodHRwczovL3YyLnRhdXJpLmFwcC9yZWZlcmVuY2UvamF2YXNjcmlwdC9hcGkvbmFtZXNwYWNlcGF0aC8jdGVtcGxhdGVkaXIgfCAkVEVNUExBVEV9LFxuICoge0BsaW5rY29kZSBodHRwczovL3YyLnRhdXJpLmFwcC9yZWZlcmVuY2UvamF2YXNjcmlwdC9hcGkvbmFtZXNwYWNlcGF0aC8jdmlkZW9kaXIgfCAkVklERU99LFxuICoge0BsaW5rY29kZSBodHRwczovL3YyLnRhdXJpLmFwcC9yZWZlcmVuY2UvamF2YXNjcmlwdC9hcGkvbmFtZXNwYWNlcGF0aC8jcmVzb3VyY2VkaXIgfCAkUkVTT1VSQ0V9LFxuICoge0BsaW5rY29kZSBodHRwczovL3YyLnRhdXJpLmFwcC9yZWZlcmVuY2UvamF2YXNjcmlwdC9hcGkvbmFtZXNwYWNlcGF0aC8jdGVtcGRpciB8ICRURU1QfS5cbiAqXG4gKiBUcnlpbmcgdG8gZXhlY3V0ZSBhbnkgQVBJIHdpdGggYSBVUkwgbm90IGNvbmZpZ3VyZWQgb24gdGhlIHNjb3BlIHJlc3VsdHMgaW4gYSBwcm9taXNlIHJlamVjdGlvbiBkdWUgdG8gZGVuaWVkIGFjY2Vzcy5cbiAqXG4gKiBAbW9kdWxlXG4gKi9cbnZhciBTZWVrTW9kZTtcbihmdW5jdGlvbiAoU2Vla01vZGUpIHtcbiAgICBTZWVrTW9kZVtTZWVrTW9kZVtcIlN0YXJ0XCJdID0gMF0gPSBcIlN0YXJ0XCI7XG4gICAgU2Vla01vZGVbU2Vla01vZGVbXCJDdXJyZW50XCJdID0gMV0gPSBcIkN1cnJlbnRcIjtcbiAgICBTZWVrTW9kZVtTZWVrTW9kZVtcIkVuZFwiXSA9IDJdID0gXCJFbmRcIjtcbn0pKFNlZWtNb2RlIHx8IChTZWVrTW9kZSA9IHt9KSk7XG5mdW5jdGlvbiBwYXJzZUZpbGVJbmZvKHIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpc0ZpbGU6IHIuaXNGaWxlLFxuICAgICAgICBpc0RpcmVjdG9yeTogci5pc0RpcmVjdG9yeSxcbiAgICAgICAgaXNTeW1saW5rOiByLmlzU3ltbGluayxcbiAgICAgICAgc2l6ZTogci5zaXplLFxuICAgICAgICBtdGltZTogci5tdGltZSAhPT0gbnVsbCA/IG5ldyBEYXRlKHIubXRpbWUpIDogbnVsbCxcbiAgICAgICAgYXRpbWU6IHIuYXRpbWUgIT09IG51bGwgPyBuZXcgRGF0ZShyLmF0aW1lKSA6IG51bGwsXG4gICAgICAgIGJpcnRodGltZTogci5iaXJ0aHRpbWUgIT09IG51bGwgPyBuZXcgRGF0ZShyLmJpcnRodGltZSkgOiBudWxsLFxuICAgICAgICByZWFkb25seTogci5yZWFkb25seSxcbiAgICAgICAgZmlsZUF0dHJpYnV0ZXM6IHIuZmlsZUF0dHJpYnV0ZXMsXG4gICAgICAgIGRldjogci5kZXYsXG4gICAgICAgIGlubzogci5pbm8sXG4gICAgICAgIG1vZGU6IHIubW9kZSxcbiAgICAgICAgbmxpbms6IHIubmxpbmssXG4gICAgICAgIHVpZDogci51aWQsXG4gICAgICAgIGdpZDogci5naWQsXG4gICAgICAgIHJkZXY6IHIucmRldixcbiAgICAgICAgYmxrc2l6ZTogci5ibGtzaXplLFxuICAgICAgICBibG9ja3M6IHIuYmxvY2tzXG4gICAgfTtcbn1cbi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3phcHRoZWRpbmdiYXQvMzhlYmZiZWRkOTgzOTY2MjRlNWI1ZjJmZjQ2MjYxMWRcbi8qKiBDb252ZXJ0cyBhIGJpZy1lbmRpYW4gZWlnaHQgYnl0ZSBhcnJheSB0byBudW1iZXIgICovXG5mdW5jdGlvbiBmcm9tQnl0ZXMoYnVmZmVyKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoYnVmZmVyKTtcbiAgICBjb25zdCBzaXplID0gYnl0ZXMuYnl0ZUxlbmd0aDtcbiAgICBsZXQgeCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHNlY3VyaXR5L2RldGVjdC1vYmplY3QtaW5qZWN0aW9uXG4gICAgICAgIGNvbnN0IGJ5dGUgPSBieXRlc1tpXTtcbiAgICAgICAgeCAqPSAweDEwMDtcbiAgICAgICAgeCArPSBieXRlO1xuICAgIH1cbiAgICByZXR1cm4geDtcbn1cbi8qKlxuICogIFRoZSBUYXVyaSBhYnN0cmFjdGlvbiBmb3IgcmVhZGluZyBhbmQgd3JpdGluZyBmaWxlcy5cbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuY2xhc3MgRmlsZUhhbmRsZSBleHRlbmRzIFJlc291cmNlIHtcbiAgICAvKipcbiAgICAgKiBSZWFkcyB1cCB0byBgcC5ieXRlTGVuZ3RoYCBieXRlcyBpbnRvIGBwYC4gSXQgcmVzb2x2ZXMgdG8gdGhlIG51bWJlciBvZlxuICAgICAqIGJ5dGVzIHJlYWQgKGAwYCA8IGBuYCA8PSBgcC5ieXRlTGVuZ3RoYCkgYW5kIHJlamVjdHMgaWYgYW55IGVycm9yXG4gICAgICogZW5jb3VudGVyZWQuIEV2ZW4gaWYgYHJlYWQoKWAgcmVzb2x2ZXMgdG8gYG5gIDwgYHAuYnl0ZUxlbmd0aGAsIGl0IG1heVxuICAgICAqIHVzZSBhbGwgb2YgYHBgIGFzIHNjcmF0Y2ggc3BhY2UgZHVyaW5nIHRoZSBjYWxsLiBJZiBzb21lIGRhdGEgaXNcbiAgICAgKiBhdmFpbGFibGUgYnV0IG5vdCBgcC5ieXRlTGVuZ3RoYCBieXRlcywgYHJlYWQoKWAgY29udmVudGlvbmFsbHkgcmVzb2x2ZXNcbiAgICAgKiB0byB3aGF0IGlzIGF2YWlsYWJsZSBpbnN0ZWFkIG9mIHdhaXRpbmcgZm9yIG1vcmUuXG4gICAgICpcbiAgICAgKiBXaGVuIGByZWFkKClgIGVuY291bnRlcnMgZW5kLW9mLWZpbGUgY29uZGl0aW9uLCBpdCByZXNvbHZlcyB0byBFT0ZcbiAgICAgKiAoYG51bGxgKS5cbiAgICAgKlxuICAgICAqIFdoZW4gYHJlYWQoKWAgZW5jb3VudGVycyBhbiBlcnJvciwgaXQgcmVqZWN0cyB3aXRoIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogQ2FsbGVycyBzaG91bGQgYWx3YXlzIHByb2Nlc3MgdGhlIGBuYCA+IGAwYCBieXRlcyByZXR1cm5lZCBiZWZvcmVcbiAgICAgKiBjb25zaWRlcmluZyB0aGUgRU9GIChgbnVsbGApLiBEb2luZyBzbyBjb3JyZWN0bHkgaGFuZGxlcyBJL08gZXJyb3JzIHRoYXRcbiAgICAgKiBoYXBwZW4gYWZ0ZXIgcmVhZGluZyBzb21lIGJ5dGVzIGFuZCBhbHNvIGJvdGggb2YgdGhlIGFsbG93ZWQgRU9GXG4gICAgICogYmVoYXZpb3JzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogaW1wb3J0IHsgb3BlbiwgQmFzZURpcmVjdG9yeSB9IGZyb20gXCJAdGF1cmktYXBwcy9wbHVnaW4tZnNcIlxuICAgICAqIC8vIGlmIFwiJEFQUENPTkZJRy9mb28vYmFyLnR4dFwiIGNvbnRhaW5zIHRoZSB0ZXh0IFwiaGVsbG8gd29ybGRcIjpcbiAgICAgKiBjb25zdCBmaWxlID0gYXdhaXQgb3BlbihcImZvby9iYXIudHh0XCIsIHsgYmFzZURpcjogQmFzZURpcmVjdG9yeS5BcHBDb25maWcgfSk7XG4gICAgICogY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkoMTAwKTtcbiAgICAgKiBjb25zdCBudW1iZXJPZkJ5dGVzUmVhZCA9IGF3YWl0IGZpbGUucmVhZChidWYpOyAvLyAxMSBieXRlc1xuICAgICAqIGNvbnN0IHRleHQgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnVmKTsgIC8vIFwiaGVsbG8gd29ybGRcIlxuICAgICAqIGF3YWl0IGZpbGUuY2xvc2UoKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqL1xuICAgIGFzeW5jIHJlYWQoYnVmZmVyKSB7XG4gICAgICAgIGlmIChidWZmZXIuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGludm9rZSgncGx1Z2luOmZzfHJlYWQnLCB7XG4gICAgICAgICAgICByaWQ6IHRoaXMucmlkLFxuICAgICAgICAgICAgbGVuOiBidWZmZXIuYnl0ZUxlbmd0aFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUnVzdCBzaWRlIHdpbGwgbmV2ZXIgcmV0dXJuIGFuIGVtcHR5IGFycmF5IGZvciB0aGlzIGNvbW1hbmQgYW5kXG4gICAgICAgIC8vIGVuc3VyZSB0aGVyZSBpcyBhdCBsZWFzdCA4IGVsZW1lbnRzIHRoZXJlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGlzIGlzIGFuIG9wdGltaXphdGlvbiB0byBpbmNsdWRlIHRoZSBudW1iZXIgb2YgcmVhZCBieXRlcyAoYXMgYmlnZW5kaWFuIGJ5dGVzKVxuICAgICAgICAvLyBhdCB0aGUgZW5kIG9mIHJldHVybmVkIGFycmF5IHRvIGF2b2lkIHNlcmlhbGl6YXRpb24gb3ZlcmhlYWQgb2Ygc2VwYXJhdGUgdmFsdWVzLlxuICAgICAgICBjb25zdCBucmVhZCA9IGZyb21CeXRlcyhkYXRhLnNsaWNlKC04KSk7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gbmV3IFVpbnQ4QXJyYXkoZGF0YSkgOiBkYXRhO1xuICAgICAgICBidWZmZXIuc2V0KGJ5dGVzLnNsaWNlKDAsIGJ5dGVzLmxlbmd0aCAtIDgpKTtcbiAgICAgICAgcmV0dXJuIG5yZWFkID09PSAwID8gbnVsbCA6IG5yZWFkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWVrIHNldHMgdGhlIG9mZnNldCBmb3IgdGhlIG5leHQgYHJlYWQoKWAgb3IgYHdyaXRlKClgIHRvIG9mZnNldCxcbiAgICAgKiBpbnRlcnByZXRlZCBhY2NvcmRpbmcgdG8gYHdoZW5jZWA6IGBTdGFydGAgbWVhbnMgcmVsYXRpdmUgdG8gdGhlXG4gICAgICogc3RhcnQgb2YgdGhlIGZpbGUsIGBDdXJyZW50YCBtZWFucyByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBvZmZzZXQsXG4gICAgICogYW5kIGBFbmRgIG1lYW5zIHJlbGF0aXZlIHRvIHRoZSBlbmQuIFNlZWsgcmVzb2x2ZXMgdG8gdGhlIG5ldyBvZmZzZXRcbiAgICAgKiByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGZpbGUuXG4gICAgICpcbiAgICAgKiBTZWVraW5nIHRvIGFuIG9mZnNldCBiZWZvcmUgdGhlIHN0YXJ0IG9mIHRoZSBmaWxlIGlzIGFuIGVycm9yLiBTZWVraW5nIHRvXG4gICAgICogYW55IHBvc2l0aXZlIG9mZnNldCBpcyBsZWdhbCwgYnV0IHRoZSBiZWhhdmlvciBvZiBzdWJzZXF1ZW50IEkvT1xuICAgICAqIG9wZXJhdGlvbnMgb24gdGhlIHVuZGVybHlpbmcgb2JqZWN0IGlzIGltcGxlbWVudGF0aW9uLWRlcGVuZGVudC5cbiAgICAgKiBJdCByZXR1cm5zIHRoZSBudW1iZXIgb2YgY3Vyc29yIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogaW1wb3J0IHsgb3BlbiwgU2Vla01vZGUsIEJhc2VEaXJlY3RvcnkgfSBmcm9tICdAdGF1cmktYXBwcy9wbHVnaW4tZnMnO1xuICAgICAqXG4gICAgICogLy8gR2l2ZW4gaGVsbG8udHh0IHBvaW50aW5nIHRvIGZpbGUgd2l0aCBcIkhlbGxvIHdvcmxkXCIsIHdoaWNoIGlzIDExIGJ5dGVzIGxvbmc6XG4gICAgICogY29uc3QgZmlsZSA9IGF3YWl0IG9wZW4oJ2hlbGxvLnR4dCcsIHsgcmVhZDogdHJ1ZSwgd3JpdGU6IHRydWUsIHRydW5jYXRlOiB0cnVlLCBjcmVhdGU6IHRydWUsIGJhc2VEaXI6IEJhc2VEaXJlY3RvcnkuQXBwTG9jYWxEYXRhIH0pO1xuICAgICAqIGF3YWl0IGZpbGUud3JpdGUobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKFwiSGVsbG8gd29ybGRcIikpO1xuICAgICAqXG4gICAgICogLy8gU2VlayA2IGJ5dGVzIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBmaWxlXG4gICAgICogY29uc29sZS5sb2coYXdhaXQgZmlsZS5zZWVrKDYsIFNlZWtNb2RlLlN0YXJ0KSk7IC8vIFwiNlwiXG4gICAgICogLy8gU2VlayAyIG1vcmUgYnl0ZXMgZnJvbSB0aGUgY3VycmVudCBwb3NpdGlvblxuICAgICAqIGNvbnNvbGUubG9nKGF3YWl0IGZpbGUuc2VlaygyLCBTZWVrTW9kZS5DdXJyZW50KSk7IC8vIFwiOFwiXG4gICAgICogLy8gU2VlayBiYWNrd2FyZHMgMiBieXRlcyBmcm9tIHRoZSBlbmQgb2YgdGhlIGZpbGVcbiAgICAgKiBjb25zb2xlLmxvZyhhd2FpdCBmaWxlLnNlZWsoLTIsIFNlZWtNb2RlLkVuZCkpOyAvLyBcIjlcIiAoZS5nLiAxMS0yKVxuICAgICAqXG4gICAgICogYXdhaXQgZmlsZS5jbG9zZSgpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICovXG4gICAgYXN5bmMgc2VlayhvZmZzZXQsIHdoZW5jZSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgaW52b2tlKCdwbHVnaW46ZnN8c2VlaycsIHtcbiAgICAgICAgICAgIHJpZDogdGhpcy5yaWQsXG4gICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICB3aGVuY2VcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB7QGxpbmtjb2RlIEZpbGVJbmZvIH0gZm9yIHRoaXMgZmlsZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGltcG9ydCB7IG9wZW4sIEJhc2VEaXJlY3RvcnkgfSBmcm9tICdAdGF1cmktYXBwcy9wbHVnaW4tZnMnO1xuICAgICAqIGNvbnN0IGZpbGUgPSBhd2FpdCBvcGVuKFwiZmlsZS50eHRcIiwgeyByZWFkOiB0cnVlLCBiYXNlRGlyOiBCYXNlRGlyZWN0b3J5LkFwcExvY2FsRGF0YSB9KTtcbiAgICAgKiBjb25zdCBmaWxlSW5mbyA9IGF3YWl0IGZpbGUuc3RhdCgpO1xuICAgICAqIGNvbnNvbGUubG9nKGZpbGVJbmZvLmlzRmlsZSk7IC8vIHRydWVcbiAgICAgKiBhd2FpdCBmaWxlLmNsb3NlKCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKi9cbiAgICBhc3luYyBzdGF0KCkge1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBpbnZva2UoJ3BsdWdpbjpmc3xmc3RhdCcsIHtcbiAgICAgICAgICAgIHJpZDogdGhpcy5yaWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXJzZUZpbGVJbmZvKHJlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRydW5jYXRlcyBvciBleHRlbmRzIHRoaXMgZmlsZSwgdG8gcmVhY2ggdGhlIHNwZWNpZmllZCBgbGVuYC5cbiAgICAgKiBJZiBgbGVuYCBpcyBub3Qgc3BlY2lmaWVkIHRoZW4gdGhlIGVudGlyZSBmaWxlIGNvbnRlbnRzIGFyZSB0cnVuY2F0ZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBpbXBvcnQgeyBvcGVuLCBCYXNlRGlyZWN0b3J5IH0gZnJvbSAnQHRhdXJpLWFwcHMvcGx1Z2luLWZzJztcbiAgICAgKlxuICAgICAqIC8vIHRydW5jYXRlIHRoZSBlbnRpcmUgZmlsZVxuICAgICAqIGNvbnN0IGZpbGUgPSBhd2FpdCBvcGVuKFwibXlfZmlsZS50eHRcIiwgeyByZWFkOiB0cnVlLCB3cml0ZTogdHJ1ZSwgY3JlYXRlOiB0cnVlLCBiYXNlRGlyOiBCYXNlRGlyZWN0b3J5LkFwcExvY2FsRGF0YSB9KTtcbiAgICAgKiBhd2FpdCBmaWxlLnRydW5jYXRlKCk7XG4gICAgICpcbiAgICAgKiAvLyB0cnVuY2F0ZSBwYXJ0IG9mIHRoZSBmaWxlXG4gICAgICogY29uc3QgZmlsZSA9IGF3YWl0IG9wZW4oXCJteV9maWxlLnR4dFwiLCB7IHJlYWQ6IHRydWUsIHdyaXRlOiB0cnVlLCBjcmVhdGU6IHRydWUsIGJhc2VEaXI6IEJhc2VEaXJlY3RvcnkuQXBwTG9jYWxEYXRhIH0pO1xuICAgICAqIGF3YWl0IGZpbGUud3JpdGUobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKFwiSGVsbG8gV29ybGRcIikpO1xuICAgICAqIGF3YWl0IGZpbGUudHJ1bmNhdGUoNyk7XG4gICAgICogY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgICAgKiBhd2FpdCBmaWxlLnJlYWQoZGF0YSk7XG4gICAgICogY29uc29sZS5sb2cobmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGRhdGEpKTsgLy8gSGVsbG8gV1xuICAgICAqIGF3YWl0IGZpbGUuY2xvc2UoKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqL1xuICAgIGFzeW5jIHRydW5jYXRlKGxlbikge1xuICAgICAgICBhd2FpdCBpbnZva2UoJ3BsdWdpbjpmc3xmdHJ1bmNhdGUnLCB7XG4gICAgICAgICAgICByaWQ6IHRoaXMucmlkLFxuICAgICAgICAgICAgbGVuXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYGRhdGEuYnl0ZUxlbmd0aGAgYnl0ZXMgZnJvbSBgZGF0YWAgdG8gdGhlIHVuZGVybHlpbmcgZGF0YSBzdHJlYW0uIEl0XG4gICAgICogcmVzb2x2ZXMgdG8gdGhlIG51bWJlciBvZiBieXRlcyB3cml0dGVuIGZyb20gYGRhdGFgIChgMGAgPD0gYG5gIDw9XG4gICAgICogYGRhdGEuYnl0ZUxlbmd0aGApIG9yIHJlamVjdCB3aXRoIHRoZSBlcnJvciBlbmNvdW50ZXJlZCB0aGF0IGNhdXNlZCB0aGVcbiAgICAgKiB3cml0ZSB0byBzdG9wIGVhcmx5LiBgd3JpdGUoKWAgbXVzdCByZWplY3Qgd2l0aCBhIG5vbi1udWxsIGVycm9yIGlmXG4gICAgICogd291bGQgcmVzb2x2ZSB0byBgbmAgPCBgZGF0YS5ieXRlTGVuZ3RoYC4gYHdyaXRlKClgIG11c3Qgbm90IG1vZGlmeSB0aGVcbiAgICAgKiBzbGljZSBkYXRhLCBldmVuIHRlbXBvcmFyaWx5LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogaW1wb3J0IHsgb3Blbiwgd3JpdGUsIEJhc2VEaXJlY3RvcnkgfSBmcm9tICdAdGF1cmktYXBwcy9wbHVnaW4tZnMnO1xuICAgICAqIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICAgKiBjb25zdCBkYXRhID0gZW5jb2Rlci5lbmNvZGUoXCJIZWxsbyB3b3JsZFwiKTtcbiAgICAgKiBjb25zdCBmaWxlID0gYXdhaXQgb3BlbihcImJhci50eHRcIiwgeyB3cml0ZTogdHJ1ZSwgYmFzZURpcjogQmFzZURpcmVjdG9yeS5BcHBMb2NhbERhdGEgfSk7XG4gICAgICogY29uc3QgYnl0ZXNXcml0dGVuID0gYXdhaXQgZmlsZS53cml0ZShkYXRhKTsgLy8gMTFcbiAgICAgKiBhd2FpdCBmaWxlLmNsb3NlKCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKi9cbiAgICBhc3luYyB3cml0ZShkYXRhKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBpbnZva2UoJ3BsdWdpbjpmc3x3cml0ZScsIHtcbiAgICAgICAgICAgIHJpZDogdGhpcy5yaWQsXG4gICAgICAgICAgICBkYXRhXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhIGZpbGUgaWYgbm9uZSBleGlzdHMgb3IgdHJ1bmNhdGVzIGFuIGV4aXN0aW5nIGZpbGUgYW5kIHJlc29sdmVzIHRvXG4gKiAgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rY29kZSBGaWxlSGFuZGxlIH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IGNyZWF0ZSwgQmFzZURpcmVjdG9yeSB9IGZyb20gXCJAdGF1cmktYXBwcy9wbHVnaW4tZnNcIlxuICogY29uc3QgZmlsZSA9IGF3YWl0IGNyZWF0ZShcImZvby9iYXIudHh0XCIsIHsgYmFzZURpcjogQmFzZURpcmVjdG9yeS5BcHBDb25maWcgfSk7XG4gKiBhd2FpdCBmaWxlLndyaXRlKG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShcIkhlbGxvIHdvcmxkXCIpKTtcbiAqIGF3YWl0IGZpbGUuY2xvc2UoKTtcbiAqIGBgYFxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5hc3luYyBmdW5jdGlvbiBjcmVhdGUocGF0aCwgb3B0aW9ucykge1xuICAgIGlmIChwYXRoIGluc3RhbmNlb2YgVVJMICYmIHBhdGgucHJvdG9jb2wgIT09ICdmaWxlOicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTXVzdCBiZSBhIGZpbGUgVVJMLicpO1xuICAgIH1cbiAgICBjb25zdCByaWQgPSBhd2FpdCBpbnZva2UoJ3BsdWdpbjpmc3xjcmVhdGUnLCB7XG4gICAgICAgIHBhdGg6IHBhdGggaW5zdGFuY2VvZiBVUkwgPyBwYXRoLnRvU3RyaW5nKCkgOiBwYXRoLFxuICAgICAgICBvcHRpb25zXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBGaWxlSGFuZGxlKHJpZCk7XG59XG4vKipcbiAqIE9wZW4gYSBmaWxlIGFuZCByZXNvbHZlIHRvIGFuIGluc3RhbmNlIG9mIHtAbGlua2NvZGUgRmlsZUhhbmRsZX0uIFRoZVxuICogZmlsZSBkb2VzIG5vdCBuZWVkIHRvIHByZXZpb3VzbHkgZXhpc3QgaWYgdXNpbmcgdGhlIGBjcmVhdGVgIG9yIGBjcmVhdGVOZXdgXG4gKiBvcGVuIG9wdGlvbnMuIEl0IGlzIHRoZSBjYWxsZXJzIHJlc3BvbnNpYmlsaXR5IHRvIGNsb3NlIHRoZSBmaWxlIHdoZW4gZmluaXNoZWRcbiAqIHdpdGggaXQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IG9wZW4sIEJhc2VEaXJlY3RvcnkgfSBmcm9tIFwiQHRhdXJpLWFwcHMvcGx1Z2luLWZzXCJcbiAqIGNvbnN0IGZpbGUgPSBhd2FpdCBvcGVuKFwiZm9vL2Jhci50eHRcIiwgeyByZWFkOiB0cnVlLCB3cml0ZTogdHJ1ZSwgYmFzZURpcjogQmFzZURpcmVjdG9yeS5BcHBMb2NhbERhdGEgfSk7XG4gKiAvLyBEbyB3b3JrIHdpdGggZmlsZVxuICogYXdhaXQgZmlsZS5jbG9zZSgpO1xuICogYGBgXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIG9wZW4ocGF0aCwgb3B0aW9ucykge1xuICAgIGlmIChwYXRoIGluc3RhbmNlb2YgVVJMICYmIHBhdGgucHJvdG9jb2wgIT09ICdmaWxlOicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTXVzdCBiZSBhIGZpbGUgVVJMLicpO1xuICAgIH1cbiAgICBjb25zdCByaWQgPSBhd2FpdCBpbnZva2UoJ3BsdWdpbjpmc3xvcGVuJywge1xuICAgICAgICBwYXRoOiBwYXRoIGluc3RhbmNlb2YgVVJMID8gcGF0aC50b1N0cmluZygpIDogcGF0aCxcbiAgICAgICAgb3B0aW9uc1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgRmlsZUhhbmRsZShyaWQpO1xufVxuLyoqXG4gKiBDb3BpZXMgdGhlIGNvbnRlbnRzIGFuZCBwZXJtaXNzaW9ucyBvZiBvbmUgZmlsZSB0byBhbm90aGVyIHNwZWNpZmllZCBwYXRoLCBieSBkZWZhdWx0IGNyZWF0aW5nIGEgbmV3IGZpbGUgaWYgbmVlZGVkLCBlbHNlIG92ZXJ3cml0aW5nLlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IGNvcHlGaWxlLCBCYXNlRGlyZWN0b3J5IH0gZnJvbSAnQHRhdXJpLWFwcHMvcGx1Z2luLWZzJztcbiAqIGF3YWl0IGNvcHlGaWxlKCdhcHAuY29uZicsICdhcHAuY29uZi5iaycsIHsgZnJvbVBhdGhCYXNlRGlyOiBCYXNlRGlyZWN0b3J5LkFwcENvbmZpZywgdG9QYXRoQmFzZURpcjogQmFzZURpcmVjdG9yeS5BcHBDb25maWcgfSk7XG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuYXN5bmMgZnVuY3Rpb24gY29weUZpbGUoZnJvbVBhdGgsIHRvUGF0aCwgb3B0aW9ucykge1xuICAgIGlmICgoZnJvbVBhdGggaW5zdGFuY2VvZiBVUkwgJiYgZnJvbVBhdGgucHJvdG9jb2wgIT09ICdmaWxlOicpIHx8XG4gICAgICAgICh0b1BhdGggaW5zdGFuY2VvZiBVUkwgJiYgdG9QYXRoLnByb3RvY29sICE9PSAnZmlsZTonKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNdXN0IGJlIGEgZmlsZSBVUkwuJyk7XG4gICAgfVxuICAgIGF3YWl0IGludm9rZSgncGx1Z2luOmZzfGNvcHlfZmlsZScsIHtcbiAgICAgICAgZnJvbVBhdGg6IGZyb21QYXRoIGluc3RhbmNlb2YgVVJMID8gZnJvbVBhdGgudG9TdHJpbmcoKSA6IGZyb21QYXRoLFxuICAgICAgICB0b1BhdGg6IHRvUGF0aCBpbnN0YW5jZW9mIFVSTCA/IHRvUGF0aC50b1N0cmluZygpIDogdG9QYXRoLFxuICAgICAgICBvcHRpb25zXG4gICAgfSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZGlyZWN0b3J5IHdpdGggdGhlIHNwZWNpZmllZCBwYXRoLlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IG1rZGlyLCBCYXNlRGlyZWN0b3J5IH0gZnJvbSAnQHRhdXJpLWFwcHMvcGx1Z2luLWZzJztcbiAqIGF3YWl0IG1rZGlyKCd1c2VycycsIHsgYmFzZURpcjogQmFzZURpcmVjdG9yeS5BcHBMb2NhbERhdGEgfSk7XG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuYXN5bmMgZnVuY3Rpb24gbWtkaXIocGF0aCwgb3B0aW9ucykge1xuICAgIGlmIChwYXRoIGluc3RhbmNlb2YgVVJMICYmIHBhdGgucHJvdG9jb2wgIT09ICdmaWxlOicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTXVzdCBiZSBhIGZpbGUgVVJMLicpO1xuICAgIH1cbiAgICBhd2FpdCBpbnZva2UoJ3BsdWdpbjpmc3xta2RpcicsIHtcbiAgICAgICAgcGF0aDogcGF0aCBpbnN0YW5jZW9mIFVSTCA/IHBhdGgudG9TdHJpbmcoKSA6IHBhdGgsXG4gICAgICAgIG9wdGlvbnNcbiAgICB9KTtcbn1cbi8qKlxuICogUmVhZHMgdGhlIGRpcmVjdG9yeSBnaXZlbiBieSBwYXRoIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIGBEaXJFbnRyeWAuXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgcmVhZERpciwgQmFzZURpcmVjdG9yeSB9IGZyb20gJ0B0YXVyaS1hcHBzL3BsdWdpbi1mcyc7XG4gKiBpbXBvcnQgeyBqb2luIH0gZnJvbSAnQHRhdXJpLWFwcHMvYXBpL3BhdGgnO1xuICogY29uc3QgZGlyID0gXCJ1c2Vyc1wiXG4gKiBjb25zdCBlbnRyaWVzID0gYXdhaXQgcmVhZERpcigndXNlcnMnLCB7IGJhc2VEaXI6IEJhc2VEaXJlY3RvcnkuQXBwTG9jYWxEYXRhIH0pO1xuICogcHJvY2Vzc0VudHJpZXNSZWN1cnNpdmVseShkaXIsIGVudHJpZXMpO1xuICogYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0VudHJpZXNSZWN1cnNpdmVseShwYXJlbnQsIGVudHJpZXMpIHtcbiAqICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gKiAgICAgY29uc29sZS5sb2coYEVudHJ5OiAke2VudHJ5Lm5hbWV9YCk7XG4gKiAgICAgaWYgKGVudHJ5LmlzRGlyZWN0b3J5KSB7XG4gKiAgICAgICAgY29uc3QgZGlyID0gYXdhaXQgam9pbihwYXJlbnQsIGVudHJ5Lm5hbWUpO1xuICogICAgICAgcHJvY2Vzc0VudHJpZXNSZWN1cnNpdmVseShkaXIsIGF3YWl0IHJlYWREaXIoZGlyLCB7IGJhc2VEaXI6IEJhc2VEaXJlY3RvcnkuQXBwTG9jYWxEYXRhIH0pKVxuICogICAgIH1cbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlYWREaXIocGF0aCwgb3B0aW9ucykge1xuICAgIGlmIChwYXRoIGluc3RhbmNlb2YgVVJMICYmIHBhdGgucHJvdG9jb2wgIT09ICdmaWxlOicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTXVzdCBiZSBhIGZpbGUgVVJMLicpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgaW52b2tlKCdwbHVnaW46ZnN8cmVhZF9kaXInLCB7XG4gICAgICAgIHBhdGg6IHBhdGggaW5zdGFuY2VvZiBVUkwgPyBwYXRoLnRvU3RyaW5nKCkgOiBwYXRoLFxuICAgICAgICBvcHRpb25zXG4gICAgfSk7XG59XG4vKipcbiAqIFJlYWRzIGFuZCByZXNvbHZlcyB0byB0aGUgZW50aXJlIGNvbnRlbnRzIG9mIGEgZmlsZSBhcyBhbiBhcnJheSBvZiBieXRlcy5cbiAqIFRleHREZWNvZGVyIGNhbiBiZSB1c2VkIHRvIHRyYW5zZm9ybSB0aGUgYnl0ZXMgdG8gc3RyaW5nIGlmIHJlcXVpcmVkLlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IHJlYWRGaWxlLCBCYXNlRGlyZWN0b3J5IH0gZnJvbSAnQHRhdXJpLWFwcHMvcGx1Z2luLWZzJztcbiAqIGNvbnN0IGNvbnRlbnRzID0gYXdhaXQgcmVhZEZpbGUoJ2F2YXRhci5wbmcnLCB7IGJhc2VEaXI6IEJhc2VEaXJlY3RvcnkuUmVzb3VyY2UgfSk7XG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVhZEZpbGUocGF0aCwgb3B0aW9ucykge1xuICAgIGlmIChwYXRoIGluc3RhbmNlb2YgVVJMICYmIHBhdGgucHJvdG9jb2wgIT09ICdmaWxlOicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTXVzdCBiZSBhIGZpbGUgVVJMLicpO1xuICAgIH1cbiAgICBjb25zdCBhcnIgPSBhd2FpdCBpbnZva2UoJ3BsdWdpbjpmc3xyZWFkX2ZpbGUnLCB7XG4gICAgICAgIHBhdGg6IHBhdGggaW5zdGFuY2VvZiBVUkwgPyBwYXRoLnRvU3RyaW5nKCkgOiBwYXRoLFxuICAgICAgICBvcHRpb25zXG4gICAgfSk7XG4gICAgcmV0dXJuIGFyciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gbmV3IFVpbnQ4QXJyYXkoYXJyKSA6IFVpbnQ4QXJyYXkuZnJvbShhcnIpO1xufVxuLyoqXG4gKiBSZWFkcyBhbmQgcmV0dXJucyB0aGUgZW50aXJlIGNvbnRlbnRzIG9mIGEgZmlsZSBhcyBVVEYtOCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgcmVhZFRleHRGaWxlLCBCYXNlRGlyZWN0b3J5IH0gZnJvbSAnQHRhdXJpLWFwcHMvcGx1Z2luLWZzJztcbiAqIGNvbnN0IGNvbnRlbnRzID0gYXdhaXQgcmVhZFRleHRGaWxlKCdhcHAuY29uZicsIHsgYmFzZURpcjogQmFzZURpcmVjdG9yeS5BcHBDb25maWcgfSk7XG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVhZFRleHRGaWxlKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAocGF0aCBpbnN0YW5jZW9mIFVSTCAmJiBwYXRoLnByb3RvY29sICE9PSAnZmlsZTonKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ011c3QgYmUgYSBmaWxlIFVSTC4nKTtcbiAgICB9XG4gICAgY29uc3QgYXJyID0gYXdhaXQgaW52b2tlKCdwbHVnaW46ZnN8cmVhZF90ZXh0X2ZpbGUnLCB7XG4gICAgICAgIHBhdGg6IHBhdGggaW5zdGFuY2VvZiBVUkwgPyBwYXRoLnRvU3RyaW5nKCkgOiBwYXRoLFxuICAgICAgICBvcHRpb25zXG4gICAgfSk7XG4gICAgY29uc3QgYnl0ZXMgPSBhcnIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IGFyciA6IFVpbnQ4QXJyYXkuZnJvbShhcnIpO1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnl0ZXMpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGFuIGFzeW5jIHtAbGlua2NvZGUgQXN5bmNJdGVyYWJsZUl0ZXJhdG9yfSBvdmVyIHRoZSBsaW5lcyBvZiBhIGZpbGUgYXMgVVRGLTggc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IHJlYWRUZXh0RmlsZUxpbmVzLCBCYXNlRGlyZWN0b3J5IH0gZnJvbSAnQHRhdXJpLWFwcHMvcGx1Z2luLWZzJztcbiAqIGNvbnN0IGxpbmVzID0gYXdhaXQgcmVhZFRleHRGaWxlTGluZXMoJ2FwcC5jb25mJywgeyBiYXNlRGlyOiBCYXNlRGlyZWN0b3J5LkFwcENvbmZpZyB9KTtcbiAqIGZvciBhd2FpdCAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICogICBjb25zb2xlLmxvZyhsaW5lKTtcbiAqIH1cbiAqIGBgYFxuICogWW91IGNvdWxkIGFsc28gY2FsbCB7QGxpbmtjb2RlIEFzeW5jSXRlcmFibGVJdGVyYXRvci5uZXh0fSB0byBhZHZhbmNlIHRoZVxuICogaXRlcmF0b3Igc28geW91IGNhbiBsYXppbHkgcmVhZCB0aGUgbmV4dCBsaW5lIHdoZW5ldmVyIHlvdSB3YW50LlxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5hc3luYyBmdW5jdGlvbiByZWFkVGV4dEZpbGVMaW5lcyhwYXRoLCBvcHRpb25zKSB7XG4gICAgaWYgKHBhdGggaW5zdGFuY2VvZiBVUkwgJiYgcGF0aC5wcm90b2NvbCAhPT0gJ2ZpbGU6Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNdXN0IGJlIGEgZmlsZSBVUkwuJyk7XG4gICAgfVxuICAgIGNvbnN0IHBhdGhTdHIgPSBwYXRoIGluc3RhbmNlb2YgVVJMID8gcGF0aC50b1N0cmluZygpIDogcGF0aDtcbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgcGF0aDogcGF0aFN0cixcbiAgICAgICAgcmlkOiBudWxsLFxuICAgICAgICBhc3luYyBuZXh0KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmlkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yaWQgPSBhd2FpdCBpbnZva2UoJ3BsdWdpbjpmc3xyZWFkX3RleHRfZmlsZV9saW5lcycsIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogcGF0aFN0cixcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXJyID0gYXdhaXQgaW52b2tlKCdwbHVnaW46ZnN8cmVhZF90ZXh0X2ZpbGVfbGluZXNfbmV4dCcsIHsgcmlkOiB0aGlzLnJpZCB9KTtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gYXJyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBuZXcgVWludDhBcnJheShhcnIpIDogVWludDhBcnJheS5mcm9tKGFycik7XG4gICAgICAgICAgICAvLyBSdXN0IHNpZGUgd2lsbCBuZXZlciByZXR1cm4gYW4gZW1wdHkgYXJyYXkgZm9yIHRoaXMgY29tbWFuZCBhbmRcbiAgICAgICAgICAgIC8vIGVuc3VyZSB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgZWxlbWVudHMgdGhlcmUuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBhbiBvcHRpbWl6YXRpb24gdG8gaW5jbHVkZSB3aGV0aGVyIHdlIGZpbmlzaGVkIGl0ZXJhdGlvbiBvciBub3QgKDEgb3IgMClcbiAgICAgICAgICAgIC8vIGF0IHRoZSBlbmQgb2YgcmV0dXJuZWQgYXJyYXkgdG8gYXZvaWQgc2VyaWFsaXphdGlvbiBvdmVyaGVhZCBvZiBzZXBhcmF0ZSB2YWx1ZXMuXG4gICAgICAgICAgICBjb25zdCBkb25lID0gYnl0ZXNbYnl0ZXMuYnl0ZUxlbmd0aCAtIDFdID09PSAxO1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAvLyBhIGZ1bGwgaXRlcmF0aW9uIGlzIG92ZXIsIHJlc2V0IHJpZCBmb3IgbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICAgICAgICB0aGlzLnJpZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG51bGwsIGRvbmUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnl0ZXMuc2xpY2UoMCwgYnl0ZXMuYnl0ZUxlbmd0aCkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbGluZSxcbiAgICAgICAgICAgICAgICBkb25lXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuICogUmVtb3ZlcyB0aGUgbmFtZWQgZmlsZSBvciBkaXJlY3RvcnkuXG4gKiBJZiB0aGUgZGlyZWN0b3J5IGlzIG5vdCBlbXB0eSBhbmQgdGhlIGByZWN1cnNpdmVgIG9wdGlvbiBpc24ndCBzZXQgdG8gdHJ1ZSwgdGhlIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZC5cbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyByZW1vdmUsIEJhc2VEaXJlY3RvcnkgfSBmcm9tICdAdGF1cmktYXBwcy9wbHVnaW4tZnMnO1xuICogYXdhaXQgcmVtb3ZlKCd1c2Vycy9maWxlLnR4dCcsIHsgYmFzZURpcjogQmFzZURpcmVjdG9yeS5BcHBMb2NhbERhdGEgfSk7XG4gKiBhd2FpdCByZW1vdmUoJ3VzZXJzJywgeyBiYXNlRGlyOiBCYXNlRGlyZWN0b3J5LkFwcExvY2FsRGF0YSB9KTtcbiAqIGBgYFxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5hc3luYyBmdW5jdGlvbiByZW1vdmUocGF0aCwgb3B0aW9ucykge1xuICAgIGlmIChwYXRoIGluc3RhbmNlb2YgVVJMICYmIHBhdGgucHJvdG9jb2wgIT09ICdmaWxlOicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTXVzdCBiZSBhIGZpbGUgVVJMLicpO1xuICAgIH1cbiAgICBhd2FpdCBpbnZva2UoJ3BsdWdpbjpmc3xyZW1vdmUnLCB7XG4gICAgICAgIHBhdGg6IHBhdGggaW5zdGFuY2VvZiBVUkwgPyBwYXRoLnRvU3RyaW5nKCkgOiBwYXRoLFxuICAgICAgICBvcHRpb25zXG4gICAgfSk7XG59XG4vKipcbiAqIFJlbmFtZXMgKG1vdmVzKSBvbGRwYXRoIHRvIG5ld3BhdGguIFBhdGhzIG1heSBiZSBmaWxlcyBvciBkaXJlY3Rvcmllcy5cbiAqIElmIG5ld3BhdGggYWxyZWFkeSBleGlzdHMgYW5kIGlzIG5vdCBhIGRpcmVjdG9yeSwgcmVuYW1lKCkgcmVwbGFjZXMgaXQuXG4gKiBPUy1zcGVjaWZpYyByZXN0cmljdGlvbnMgbWF5IGFwcGx5IHdoZW4gb2xkcGF0aCBhbmQgbmV3cGF0aCBhcmUgaW4gZGlmZmVyZW50IGRpcmVjdG9yaWVzLlxuICpcbiAqIE9uIFVuaXgsIHRoaXMgb3BlcmF0aW9uIGRvZXMgbm90IGZvbGxvdyBzeW1saW5rcyBhdCBlaXRoZXIgcGF0aC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgcmVuYW1lLCBCYXNlRGlyZWN0b3J5IH0gZnJvbSAnQHRhdXJpLWFwcHMvcGx1Z2luLWZzJztcbiAqIGF3YWl0IHJlbmFtZSgnYXZhdGFyLnBuZycsICdkZWxldGVkLnBuZycsIHsgb2xkUGF0aEJhc2VEaXI6IEJhc2VEaXJlY3RvcnkuQXBwLCBuZXdQYXRoQmFzZURpcjogQmFzZURpcmVjdG9yeS5BcHBMb2NhbERhdGEgfSk7XG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVuYW1lKG9sZFBhdGgsIG5ld1BhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAoKG9sZFBhdGggaW5zdGFuY2VvZiBVUkwgJiYgb2xkUGF0aC5wcm90b2NvbCAhPT0gJ2ZpbGU6JykgfHxcbiAgICAgICAgKG5ld1BhdGggaW5zdGFuY2VvZiBVUkwgJiYgbmV3UGF0aC5wcm90b2NvbCAhPT0gJ2ZpbGU6JykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTXVzdCBiZSBhIGZpbGUgVVJMLicpO1xuICAgIH1cbiAgICBhd2FpdCBpbnZva2UoJ3BsdWdpbjpmc3xyZW5hbWUnLCB7XG4gICAgICAgIG9sZFBhdGg6IG9sZFBhdGggaW5zdGFuY2VvZiBVUkwgPyBvbGRQYXRoLnRvU3RyaW5nKCkgOiBvbGRQYXRoLFxuICAgICAgICBuZXdQYXRoOiBuZXdQYXRoIGluc3RhbmNlb2YgVVJMID8gbmV3UGF0aC50b1N0cmluZygpIDogbmV3UGF0aCxcbiAgICAgICAgb3B0aW9uc1xuICAgIH0pO1xufVxuLyoqXG4gKiBSZXNvbHZlcyB0byBhIHtAbGlua2NvZGUgRmlsZUluZm99IGZvciB0aGUgc3BlY2lmaWVkIGBwYXRoYC4gV2lsbCBhbHdheXNcbiAqIGZvbGxvdyBzeW1saW5rcyBidXQgd2lsbCByZWplY3QgaWYgdGhlIHN5bWxpbmsgcG9pbnRzIHRvIGEgcGF0aCBvdXRzaWRlIG9mIHRoZSBzY29wZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgc3RhdCwgQmFzZURpcmVjdG9yeSB9IGZyb20gJ0B0YXVyaS1hcHBzL3BsdWdpbi1mcyc7XG4gKiBjb25zdCBmaWxlSW5mbyA9IGF3YWl0IHN0YXQoXCJoZWxsby50eHRcIiwgeyBiYXNlRGlyOiBCYXNlRGlyZWN0b3J5LkFwcExvY2FsRGF0YSB9KTtcbiAqIGNvbnNvbGUubG9nKGZpbGVJbmZvLmlzRmlsZSk7IC8vIHRydWVcbiAqIGBgYFxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5hc3luYyBmdW5jdGlvbiBzdGF0KHBhdGgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBpbnZva2UoJ3BsdWdpbjpmc3xzdGF0Jywge1xuICAgICAgICBwYXRoOiBwYXRoIGluc3RhbmNlb2YgVVJMID8gcGF0aC50b1N0cmluZygpIDogcGF0aCxcbiAgICAgICAgb3B0aW9uc1xuICAgIH0pO1xuICAgIHJldHVybiBwYXJzZUZpbGVJbmZvKHJlcyk7XG59XG4vKipcbiAqIFJlc29sdmVzIHRvIGEge0BsaW5rY29kZSBGaWxlSW5mb30gZm9yIHRoZSBzcGVjaWZpZWQgYHBhdGhgLiBJZiBgcGF0aGAgaXMgYVxuICogc3ltbGluaywgaW5mb3JtYXRpb24gZm9yIHRoZSBzeW1saW5rIHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZCBvZiB3aGF0IGl0XG4gKiBwb2ludHMgdG8uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IGxzdGF0LCBCYXNlRGlyZWN0b3J5IH0gZnJvbSAnQHRhdXJpLWFwcHMvcGx1Z2luLWZzJztcbiAqIGNvbnN0IGZpbGVJbmZvID0gYXdhaXQgbHN0YXQoXCJoZWxsby50eHRcIiwgeyBiYXNlRGlyOiBCYXNlRGlyZWN0b3J5LkFwcExvY2FsRGF0YSB9KTtcbiAqIGNvbnNvbGUubG9nKGZpbGVJbmZvLmlzRmlsZSk7IC8vIHRydWVcbiAqIGBgYFxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5hc3luYyBmdW5jdGlvbiBsc3RhdChwYXRoLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgaW52b2tlKCdwbHVnaW46ZnN8bHN0YXQnLCB7XG4gICAgICAgIHBhdGg6IHBhdGggaW5zdGFuY2VvZiBVUkwgPyBwYXRoLnRvU3RyaW5nKCkgOiBwYXRoLFxuICAgICAgICBvcHRpb25zXG4gICAgfSk7XG4gICAgcmV0dXJuIHBhcnNlRmlsZUluZm8ocmVzKTtcbn1cbi8qKlxuICogVHJ1bmNhdGVzIG9yIGV4dGVuZHMgdGhlIHNwZWNpZmllZCBmaWxlLCB0byByZWFjaCB0aGUgc3BlY2lmaWVkIGBsZW5gLlxuICogSWYgYGxlbmAgaXMgYDBgIG9yIG5vdCBzcGVjaWZpZWQsIHRoZW4gdGhlIGVudGlyZSBmaWxlIGNvbnRlbnRzIGFyZSB0cnVuY2F0ZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IHRydW5jYXRlLCByZWFkVGV4dEZpbGUsIHdyaXRlVGV4dEZpbGUsIEJhc2VEaXJlY3RvcnkgfSBmcm9tICdAdGF1cmktYXBwcy9wbHVnaW4tZnMnO1xuICogLy8gdHJ1bmNhdGUgdGhlIGVudGlyZSBmaWxlXG4gKiBhd2FpdCB0cnVuY2F0ZShcIm15X2ZpbGUudHh0XCIsIDAsIHsgYmFzZURpcjogQmFzZURpcmVjdG9yeS5BcHBMb2NhbERhdGEgfSk7XG4gKlxuICogLy8gdHJ1bmNhdGUgcGFydCBvZiB0aGUgZmlsZVxuICogY29uc3QgZmlsZVBhdGggPSBcImZpbGUudHh0XCI7XG4gKiBhd2FpdCB3cml0ZVRleHRGaWxlKGZpbGVQYXRoLCBcIkhlbGxvIFdvcmxkXCIsIHsgYmFzZURpcjogQmFzZURpcmVjdG9yeS5BcHBMb2NhbERhdGEgfSk7XG4gKiBhd2FpdCB0cnVuY2F0ZShmaWxlUGF0aCwgNywgeyBiYXNlRGlyOiBCYXNlRGlyZWN0b3J5LkFwcExvY2FsRGF0YSB9KTtcbiAqIGNvbnN0IGRhdGEgPSBhd2FpdCByZWFkVGV4dEZpbGUoZmlsZVBhdGgsIHsgYmFzZURpcjogQmFzZURpcmVjdG9yeS5BcHBMb2NhbERhdGEgfSk7XG4gKiBjb25zb2xlLmxvZyhkYXRhKTsgIC8vIFwiSGVsbG8gV1wiXG4gKiBgYGBcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqL1xuYXN5bmMgZnVuY3Rpb24gdHJ1bmNhdGUocGF0aCwgbGVuLCBvcHRpb25zKSB7XG4gICAgaWYgKHBhdGggaW5zdGFuY2VvZiBVUkwgJiYgcGF0aC5wcm90b2NvbCAhPT0gJ2ZpbGU6Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNdXN0IGJlIGEgZmlsZSBVUkwuJyk7XG4gICAgfVxuICAgIGF3YWl0IGludm9rZSgncGx1Z2luOmZzfHRydW5jYXRlJywge1xuICAgICAgICBwYXRoOiBwYXRoIGluc3RhbmNlb2YgVVJMID8gcGF0aC50b1N0cmluZygpIDogcGF0aCxcbiAgICAgICAgbGVuLFxuICAgICAgICBvcHRpb25zXG4gICAgfSk7XG59XG4vKipcbiAqIFdyaXRlIGBkYXRhYCB0byB0aGUgZ2l2ZW4gYHBhdGhgLCBieSBkZWZhdWx0IGNyZWF0aW5nIGEgbmV3IGZpbGUgaWYgbmVlZGVkLCBlbHNlIG92ZXJ3cml0aW5nLlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IHdyaXRlRmlsZSwgQmFzZURpcmVjdG9yeSB9IGZyb20gJ0B0YXVyaS1hcHBzL3BsdWdpbi1mcyc7XG4gKlxuICogbGV0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAqIGxldCBkYXRhID0gZW5jb2Rlci5lbmNvZGUoXCJIZWxsbyBXb3JsZFwiKTtcbiAqIGF3YWl0IHdyaXRlRmlsZSgnZmlsZS50eHQnLCBkYXRhLCB7IGJhc2VEaXI6IEJhc2VEaXJlY3RvcnkuQXBwTG9jYWxEYXRhIH0pO1xuICogYGBgXG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlRmlsZShwYXRoLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgaWYgKHBhdGggaW5zdGFuY2VvZiBVUkwgJiYgcGF0aC5wcm90b2NvbCAhPT0gJ2ZpbGU6Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNdXN0IGJlIGEgZmlsZSBVUkwuJyk7XG4gICAgfVxuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0pIHtcbiAgICAgICAgY29uc3QgZmlsZSA9IGF3YWl0IG9wZW4ocGF0aCwgb3B0aW9ucyk7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgZGF0YSkge1xuICAgICAgICAgICAgYXdhaXQgZmlsZS53cml0ZShjaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgZmlsZS5jbG9zZSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXdhaXQgaW52b2tlKCdwbHVnaW46ZnN8d3JpdGVfZmlsZScsIGRhdGEsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBwYXRoOiBlbmNvZGVVUklDb21wb25lbnQocGF0aCBpbnN0YW5jZW9mIFVSTCA/IHBhdGgudG9TdHJpbmcoKSA6IHBhdGgpLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICAqIFdyaXRlcyBVVEYtOCBzdHJpbmcgYGRhdGFgIHRvIHRoZSBnaXZlbiBgcGF0aGAsIGJ5IGRlZmF1bHQgY3JlYXRpbmcgYSBuZXcgZmlsZSBpZiBuZWVkZWQsIGVsc2Ugb3ZlcndyaXRpbmcuXG4gICAgQGV4YW1wbGVcbiAgKiBgYGB0eXBlc2NyaXB0XG4gICogaW1wb3J0IHsgd3JpdGVUZXh0RmlsZSwgQmFzZURpcmVjdG9yeSB9IGZyb20gJ0B0YXVyaS1hcHBzL3BsdWdpbi1mcyc7XG4gICpcbiAgKiBhd2FpdCB3cml0ZVRleHRGaWxlKCdmaWxlLnR4dCcsIFwiSGVsbG8gd29ybGRcIiwgeyBiYXNlRGlyOiBCYXNlRGlyZWN0b3J5LkFwcExvY2FsRGF0YSB9KTtcbiAgKiBgYGBcbiAgKlxuICAqIEBzaW5jZSAyLjAuMFxuICAqL1xuYXN5bmMgZnVuY3Rpb24gd3JpdGVUZXh0RmlsZShwYXRoLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgaWYgKHBhdGggaW5zdGFuY2VvZiBVUkwgJiYgcGF0aC5wcm90b2NvbCAhPT0gJ2ZpbGU6Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNdXN0IGJlIGEgZmlsZSBVUkwuJyk7XG4gICAgfVxuICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICBhd2FpdCBpbnZva2UoJ3BsdWdpbjpmc3x3cml0ZV90ZXh0X2ZpbGUnLCBlbmNvZGVyLmVuY29kZShkYXRhKSwge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBwYXRoOiBlbmNvZGVVUklDb21wb25lbnQocGF0aCBpbnN0YW5jZW9mIFVSTCA/IHBhdGgudG9TdHJpbmcoKSA6IHBhdGgpLFxuICAgICAgICAgICAgb3B0aW9uczogSlNPTi5zdHJpbmdpZnkob3B0aW9ucylcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHBhdGggZXhpc3RzLlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IGV4aXN0cywgQmFzZURpcmVjdG9yeSB9IGZyb20gJ0B0YXVyaS1hcHBzL3BsdWdpbi1mcyc7XG4gKiAvLyBDaGVjayBpZiB0aGUgYCRBUFBEQVRBL2F2YXRhci5wbmdgIGZpbGUgZXhpc3RzXG4gKiBhd2FpdCBleGlzdHMoJ2F2YXRhci5wbmcnLCB7IGJhc2VEaXI6IEJhc2VEaXJlY3RvcnkuQXBwRGF0YSB9KTtcbiAqIGBgYFxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5hc3luYyBmdW5jdGlvbiBleGlzdHMocGF0aCwgb3B0aW9ucykge1xuICAgIGlmIChwYXRoIGluc3RhbmNlb2YgVVJMICYmIHBhdGgucHJvdG9jb2wgIT09ICdmaWxlOicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTXVzdCBiZSBhIGZpbGUgVVJMLicpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgaW52b2tlKCdwbHVnaW46ZnN8ZXhpc3RzJywge1xuICAgICAgICBwYXRoOiBwYXRoIGluc3RhbmNlb2YgVVJMID8gcGF0aC50b1N0cmluZygpIDogcGF0aCxcbiAgICAgICAgb3B0aW9uc1xuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gdW53YXRjaChyaWQpIHtcbiAgICBhd2FpdCBpbnZva2UoJ3BsdWdpbjpmc3x1bndhdGNoJywgeyByaWQgfSk7XG59XG4vKipcbiAqIFdhdGNoIGNoYW5nZXMgKGFmdGVyIGEgZGVsYXkpIG9uIGZpbGVzIG9yIGRpcmVjdG9yaWVzLlxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5hc3luYyBmdW5jdGlvbiB3YXRjaChwYXRocywgY2IsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICByZWN1cnNpdmU6IGZhbHNlLFxuICAgICAgICBkZWxheU1zOiAyMDAwLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgfTtcbiAgICBjb25zdCB3YXRjaFBhdGhzID0gQXJyYXkuaXNBcnJheShwYXRocykgPyBwYXRocyA6IFtwYXRoc107XG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHdhdGNoUGF0aHMpIHtcbiAgICAgICAgaWYgKHBhdGggaW5zdGFuY2VvZiBVUkwgJiYgcGF0aC5wcm90b2NvbCAhPT0gJ2ZpbGU6Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTXVzdCBiZSBhIGZpbGUgVVJMLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG9uRXZlbnQgPSBuZXcgQ2hhbm5lbCgpO1xuICAgIG9uRXZlbnQub25tZXNzYWdlID0gY2I7XG4gICAgY29uc3QgcmlkID0gYXdhaXQgaW52b2tlKCdwbHVnaW46ZnN8d2F0Y2gnLCB7XG4gICAgICAgIHBhdGhzOiB3YXRjaFBhdGhzLm1hcCgocCkgPT4gKHAgaW5zdGFuY2VvZiBVUkwgPyBwLnRvU3RyaW5nKCkgOiBwKSksXG4gICAgICAgIG9wdGlvbnM6IG9wdHMsXG4gICAgICAgIG9uRXZlbnRcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB2b2lkIHVud2F0Y2gocmlkKTtcbiAgICB9O1xufVxuLyoqXG4gKiBXYXRjaCBjaGFuZ2VzIG9uIGZpbGVzIG9yIGRpcmVjdG9yaWVzLlxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICovXG5hc3luYyBmdW5jdGlvbiB3YXRjaEltbWVkaWF0ZShwYXRocywgY2IsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICByZWN1cnNpdmU6IGZhbHNlLFxuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBkZWxheU1zOiBudWxsXG4gICAgfTtcbiAgICBjb25zdCB3YXRjaFBhdGhzID0gQXJyYXkuaXNBcnJheShwYXRocykgPyBwYXRocyA6IFtwYXRoc107XG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHdhdGNoUGF0aHMpIHtcbiAgICAgICAgaWYgKHBhdGggaW5zdGFuY2VvZiBVUkwgJiYgcGF0aC5wcm90b2NvbCAhPT0gJ2ZpbGU6Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTXVzdCBiZSBhIGZpbGUgVVJMLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG9uRXZlbnQgPSBuZXcgQ2hhbm5lbCgpO1xuICAgIG9uRXZlbnQub25tZXNzYWdlID0gY2I7XG4gICAgY29uc3QgcmlkID0gYXdhaXQgaW52b2tlKCdwbHVnaW46ZnN8d2F0Y2gnLCB7XG4gICAgICAgIHBhdGhzOiB3YXRjaFBhdGhzLm1hcCgocCkgPT4gKHAgaW5zdGFuY2VvZiBVUkwgPyBwLnRvU3RyaW5nKCkgOiBwKSksXG4gICAgICAgIG9wdGlvbnM6IG9wdHMsXG4gICAgICAgIG9uRXZlbnRcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB2b2lkIHVud2F0Y2gocmlkKTtcbiAgICB9O1xufVxuLyoqXG4gKiBHZXQgdGhlIHNpemUgb2YgYSBmaWxlIG9yIGRpcmVjdG9yeS4gRm9yIGZpbGVzLCB0aGUgYHN0YXRgIGZ1bmN0aW9ucyBjYW4gYmUgdXNlZCBhcyB3ZWxsLlxuICpcbiAqIElmIGBwYXRoYCBpcyBhIGRpcmVjdG9yeSwgdGhpcyBmdW5jdGlvbiB3aWxsIHJlY3Vyc2l2ZWx5IGl0ZXJhdGUgb3ZlciBldmVyeSBmaWxlIGFuZCBldmVyeSBkaXJlY3RvcnkgaW5zaWRlIG9mIGBwYXRoYCBhbmQgdGhlcmVmb3JlIHdpbGwgYmUgdmVyeSB0aW1lIGNvbnN1bWluZyBpZiB1c2VkIG9uIGxhcmdlciBkaXJlY3Rvcmllcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgc2l6ZSwgQmFzZURpcmVjdG9yeSB9IGZyb20gJ0B0YXVyaS1hcHBzL3BsdWdpbi1mcyc7XG4gKiAvLyBHZXQgdGhlIHNpemUgb2YgdGhlIGAkQVBQREFUQS90YXVyaWAgZGlyZWN0b3J5LlxuICogY29uc3QgZGlyU2l6ZSA9IGF3YWl0IHNpemUoJ3RhdXJpJywgeyBiYXNlRGlyOiBCYXNlRGlyZWN0b3J5LkFwcERhdGEgfSk7XG4gKiBjb25zb2xlLmxvZyhkaXJTaXplKTsgLy8gMTAyNFxuICogYGBgXG4gKlxuICogQHNpbmNlIDIuMS4wXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNpemUocGF0aCkge1xuICAgIGlmIChwYXRoIGluc3RhbmNlb2YgVVJMICYmIHBhdGgucHJvdG9jb2wgIT09ICdmaWxlOicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTXVzdCBiZSBhIGZpbGUgVVJMLicpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgaW52b2tlKCdwbHVnaW46ZnN8c2l6ZScsIHtcbiAgICAgICAgcGF0aDogcGF0aCBpbnN0YW5jZW9mIFVSTCA/IHBhdGgudG9TdHJpbmcoKSA6IHBhdGhcbiAgICB9KTtcbn1cblxuZXhwb3J0IHsgRmlsZUhhbmRsZSwgU2Vla01vZGUsIGNvcHlGaWxlLCBjcmVhdGUsIGV4aXN0cywgbHN0YXQsIG1rZGlyLCBvcGVuLCByZWFkRGlyLCByZWFkRmlsZSwgcmVhZFRleHRGaWxlLCByZWFkVGV4dEZpbGVMaW5lcywgcmVtb3ZlLCByZW5hbWUsIHNpemUsIHN0YXQsIHRydW5jYXRlLCB3YXRjaCwgd2F0Y2hJbW1lZGlhdGUsIHdyaXRlRmlsZSwgd3JpdGVUZXh0RmlsZSB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@tauri-apps+plugin-fs@2.2.0/node_modules/@tauri-apps/plugin-fs/dist-js/index.js\n");

/***/ })

};
;